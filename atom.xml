<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/07473b09a02f202c0f6bba5e9dc3d2fb</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.immaxfang.com/"/>
  <updated>2023-01-25T12:30:33.011Z</updated>
  <id>http://www.immaxfang.com/</id>
  
  <author>
    <name>Max Fang</name>
    <email>maxfang007@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>说说 Redis pipeline</title>
    <link href="http://www.immaxfang.com/redis-pipeline/"/>
    <id>http://www.immaxfang.com/redis-pipeline/</id>
    <published>2023-01-25T07:29:32.000Z</published>
    <updated>2023-01-25T12:30:33.011Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 客户端和服务端之间是采用 TCP 协议进行通信的，是基于 Request/Response 这种一问一答的模式，即请求一次响应一次。</p><h1 id="普通模式"><a href="# 普通模式" class="headerlink" title="普通模式"></a>普通模式 </h1><p> 我们先来看下普通模式下，一条 Redis 命令的简要执行过程：</p><ul><li>客户端发送一条命令给 redis-server，阻塞等待 redis-server 应答</li><li>redis-server 接收到命令，执行命令</li><li>redis-server 将结果返回给客户端</li></ul><span id="more"></span><p><img src="https://cdn.immaxfang.com/image123.png" alt></p><p>下面我们来简要了解下一个完整请求的交互过程。</p><p><img src="https://cdn.immaxfang.com/1666327431748.png" alt></p><ol><li>客户端调用 write () 将消息写入操作系统为 socket 分配的 send buffer 中</li><li>操作系统将 send buffer 中的内容发送到网卡，网卡通过网关路由把内容发送到服务器网卡</li><li>服务器网卡将接受到的消息写入操作系统为 socket 分配的 recv buffer</li><li>服务器进程调用 read () 从 recv buffer 中读取消息进行处理</li><li>处理完成之后，服务器调用 write () 将响应内容发送的 send buffer 中</li><li>服务器将 send buffer 中的内容通过网卡，发送到客户端</li><li>客户端操作系统将网卡中的内容放入 recv buffer 中</li><li>客户端进程调用 read () 从 recv buffer 中读取消息</li></ol><h1 id="普通模式的问题"><a href="# 普通模式的问题" class="headerlink" title="普通模式的问题"></a>普通模式的问题 </h1><p> 我们来想一下，这种情况下可能导致什么问题。<br>如果同时执行大量的命令，那对于每一个命令，都要按上面的流程走一次，当前的命令需要等待上一条命令执行应答完毕之后，才会执行。这个过程中会有多次的 RTT ，也还会伴随着很多的 IO 开销，发送网络请求等。每条命令的发送和接收的过程都会占用两边的网络传输。<br>简单的来说，每个命令的执行时间 = 客户端发送耗时 + 服务器处理耗时 + 服务器返回耗时 + 一个网络来回耗时。<br>在这里，一个网络来回耗时（RTT） 是不好控制的，也是不稳定的。它的影响因素很多，比如客户端到服务器的网络线路是否拥堵，经过了多少跳。还有就是 IO 系统调用也是耗时的，一个 read 系统调用，需要从用户态，切换到内核态。上文我们讲述一个命令的请求过程时多次降到 read 和 write 系统调用。<br>可以说一个命令的执行时间，很大程度上受到它们的限制。</p><h1 id="pipeline- 模式"><a href="#pipeline- 模式" class="headerlink" title="pipeline 模式"></a>pipeline 模式 </h1><p> 有没有什么方法来解决这种问题呢。<br>第一种方法，就是利用多线程机制，并行执行命令。<br>第二种方法，调用批量命令，例如 <code>mget</code> 等，一次操作多个键。<br>很多时候我们要执行的命令并不是一样的命令，而是一组命令，这个时候就无法使用类似 <code>mget</code> 这样的批量命令了。那还有其他的方法吗？<br>回想一下，我们初学编程的时候，老手都会告诉我们，不要在循环里面做查询。我有一个 books 列表数据，要根据 book_id 查询它们的 price，如果我们循环 books 列表，在每次循环里面取查询单个 book_id 的 price，那性能肯定是不理想的。一般我们的优化方式是将多个 book_id 取出来，一次性去查多个 book_id 的 price，这样性能就有明显的提示。即将多次小命令中的耗时操作合并到一次，从而减少总的执行时间。<br>类似的，Redis pipeline 出现了，一般称之为管道。它允许客户端一次可以发送多条命令，而不用像普通模式那样每次执行一个小命令都要等待前一个小命令执行完，服务器在接收到一堆命令后，会依次执行，然后把结果打包，再一次性返回给客户端。<br>这样可以避免频繁的命令发送，<strong>减少 RTT，减少 IO 调用次数 </strong>。前面已经介绍了，IO 调用会涉及到用户态和内核态之间的切换，在高性能的一些系统中，我们都是尽可能的减少 IO 调用。<br> 简要流程如下图：</p><p><img src="https://cdn.immaxfang.com/1666327582910.png" alt></p><ul><li><p>pipeline 的优点</p><ul><li>减少 RTT</li><li>减少 IO 调用次数</li></ul></li><li><p>基本使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pipeline pipeline =jedis.pipelined();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    pipeline.rpush(<span class="string">&quot;rediskey&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipeline.sync()</span><br></pre></td></tr></table></figure><p>总结一下 pipeline 的核心，就是 <code>客户端将一组 Redis 命令进行组装，通过一次 RTT 发送给服务器，同时服务器再将这组命令的执行结果按照顺序一次返回给客户端</code>。</p></li></ul><h1 id="pipeline- 注意问题"><a href="#pipeline- 注意问题" class="headerlink" title="pipeline 注意问题"></a>pipeline 注意问题 </h1><p> 虽然 pipeline 在某些情况下会带来不小的性能提升，但是，我们在使用的时候也需要注意。</p><ul><li>pipeline 中的命令数量不宜过多。</li></ul><p>客户端会先将多个命令写入内存 buffer 中（打包），命令过多，如果是超过了客户端设置的 buffer 上限，被客户端的处理策略处理了（不同的客户端实现可能会有差异，比如 jedis pipeline ，限制每次最大的发送字节数为 8192，缓冲区满了就发送，然后再写缓冲，最后才处理 Redis 服务器的应答）。如果客户端没有设置 buffer 上限或不支持上限设置，则会占用更多的客户端机器内存，造成客户端瘫痪。官方推荐是每次 10k 个命令。<br>建议做好规范，遇到一次包含大量命令的 pipeline，可以拆分成多个稍小的 pipeline 来完成。</p><ul><li>pipeline 一次只能运行在一个 Redis 节点上，一些集群或者 twemproxy 等中间件使用需要注意。</li></ul><p>在集群环境下，一次 pipeline 批量执行多个命令，每个命令需要根据 key 计算槽位，然后根据槽位去特定的节点上去执行命令，这样一次 pipeline 就会使用多个节点的 redis 连接，这种当前也是不支持的。</p><ul><li>pipeline 不保证原子性，如要求原子性，不建议使用 pipeline</li></ul><p>它仅是将多个命令打包发送出去而已，如果中间有命令执行异常，也会继续执行剩余命令。</p><h1 id="pipeline- 与批量操作 -mget- 等区别"><a href="#pipeline- 与批量操作 -mget- 等区别" class="headerlink" title="pipeline 与批量操作 mget 等区别"></a>pipeline 与批量操作 mget 等区别 </h1><p> 其实 <code>meget</code> 和 pipeline 优化的方向是一致的，即多个命令打包一次发送，减少网络时间。但是也是有区别的。</p><ul><li><code>mget</code> 等的场景是一个命令对应多个键值对，而 pipeline 一般是多条命令（不同的命令）</li><li><code>mget</code> 操作是一个原子操作，而 pipeline 不是原子操作</li><li><code>mget</code> 是服务端实现，而 pipeline 是客户端和服务端共同实现</li></ul><h1 id="pipeline- 与事务的区别"><a href="#pipeline- 与事务的区别" class="headerlink" title="pipeline 与事务的区别"></a>pipeline 与事务的区别 </h1><p> 这两者关注和解决的问题不是一个东西，原理也不一样。</p><ul><li>pipeline 是一次请求，服务端顺序执行，一次返回。而事务是多次请求（先 multi，再多个操作命令，最后 exec），服务端顺序执行，一次返回</li><li>pipeline 关注的是 RTT 时间和 IO 调用，事务关注的是一致性问题</li></ul><h1 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h1><p> 本文主要讲了多命令执行时耗时问题，以及 pipeline 的解决方法，和其简单的原理，以及注意点。今天的学习就到这里，改天我们接着肝。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 客户端和服务端之间是采用 TCP 协议进行通信的，是基于 Request/Response 这种一问一答的模式，即请求一次响应一次。&lt;/p&gt;
&lt;h1 id=&quot;普通模式&quot;&gt;&lt;a href=&quot;#普通模式&quot; class=&quot;headerlink&quot; title=&quot;普通模式&quot;&gt;&lt;/a&gt;普通模式&lt;/h1&gt;&lt;p&gt;我们先来看下普通模式下，一条 Redis 命令的简要执行过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送一条命令给 redis-server，阻塞等待 redis-server 应答&lt;/li&gt;
&lt;li&gt;redis-server 接收到命令，执行命令&lt;/li&gt;
&lt;li&gt;redis-server 将结果返回给客户端&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.immaxfang.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.immaxfang.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 修改默认文章路径</title>
    <link href="http://www.immaxfang.com/hexo-change-default-post-url/"/>
    <id>http://www.immaxfang.com/hexo-change-default-post-url/</id>
    <published>2023-01-25T05:30:44.000Z</published>
    <updated>2023-01-25T07:27:05.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改文章默认 -url"><a href="# 修改文章默认 -url" class="headerlink" title="修改文章默认 url"></a> 修改文章默认 url</h1><p> 在 hexo 中新建的文章，默认的 url 路径是 <code> 年 / 月 / 日 / 标题 </code> 这样的格式，这其实是不利于 SEO 的。</p><p> 可以通过修改配置文件 <code>_config.yml</code> 来调整 hexo 生成文章的展示链接。</p><p> 默认的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :year/:month/:day/:title/  </span><br></pre></td></tr></table></figure><p> 此处笔者修改为如下内容：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :title/</span><br></pre></td></tr></table></figure><p>permalink 从原来的默认值 <code>:year/:month/:day/:title/</code> 修改成 <code>:title/</code> 之后生成文章的 url 中就没有日期了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.immaxfang.com/2022/07/15/beanstalkd/</span><br></pre></td></tr></table></figure><p> 上面修改前的 url 会变成如下的 url ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.immaxfang.com/beanstalkd/</span><br></pre></td></tr></table></figure><h1 id="自定义 -url"><a href="# 自定义 -url" class="headerlink" title="自定义 url"></a> 自定义 url</h1><p> 当然，我们也可以自定义文章路径。如下面的例子，我们修改 <code>_config.yml</code> 配置一个自定义路径标签 <code>my</code> 。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:my/</span></span><br></pre></td></tr></table></figure><p> 在文章中我们给文章加入 <code>my</code> 标签，并赋予一个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---  </span><br><span class="line">title: beanstalkd  </span><br><span class="line">date: 2022-07-15 20:00</span><br><span class="line">my: a1c9d8acb9bca455ea3e81afce35e5  </span><br><span class="line">---</span><br></pre></td></tr></table></figure><p> 最终这篇文章的 url 会变成： <code>https://www.immaxfang.com/a1c9d8acb9bca455ea3e81afce35e5</code> 。</p><h1 id="参考"><a href="# 参考" class="headerlink" title="参考"></a> 参考 </h1><p><a href="https://hexo.io/zh-cn/docs/permalinks">https://hexo.io/zh-cn/docs/permalinks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;修改文章默认-url&quot;&gt;&lt;a href=&quot;#修改文章默认-url&quot; class=&quot;headerlink&quot; title=&quot;修改文章默认 url&quot;&gt;&lt;/a&gt;修改文章默认 url&lt;/h1&gt;&lt;p&gt;在 hexo 中新建的文章，默认的 url 路径是 &lt;code&gt;年/月/日/标题&lt;/code&gt; 这样的格式，这其实是不利于 SEO 的。&lt;/p&gt;
&lt;p&gt;可以通过修改配置文件 &lt;code&gt;_config.yml&lt;/code&gt; 来调整 hexo 生成文章的展示链接。&lt;/p&gt;
&lt;p&gt;默认的配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此处笔者修改为如下内容：&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.immaxfang.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.immaxfang.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>认识 Redis client-output-buffer-limit 参数与源码分析</title>
    <link href="http://www.immaxfang.com/redis-client-output-buffer-limit/"/>
    <id>http://www.immaxfang.com/redis-client-output-buffer-limit/</id>
    <published>2022-12-13T13:51:08.000Z</published>
    <updated>2023-01-24T05:56:43.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h1><p>Redis 的 client-output-buffer-limit 可以用来强制断开无法足够快从 redis 服务器端读取数据的客户端。<br> 保护机制规则如下：</p><ol><li>[hard limit] 大小限制，当某一客户端缓冲区超过设定值后，直接关闭连接。</li><li>[soft limit] 持续时间限制，当某一客户端缓冲区持续一段时间占用过大空间时关闭连接。</li></ol><p>该参数一般用在以下几类客户端中：</p><ul><li>普通 client，包括 monitor</li><li>主从同步时的 slave client</li><li>Pub/Sub 模式中的 client</li></ul><span id="more"></span><h1 id="配置介绍与分析"><a href="# 配置介绍与分析" class="headerlink" title="配置介绍与分析"></a>配置介绍与分析 </h1><p> 该参数的配置语法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard <span class="built_in">limit</span>&gt; &lt;soft <span class="built_in">limit</span>&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure><br>配置实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通 client buffer 限制 </span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line"><span class="comment"># slave client buffer 限制</span></span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line"><span class="comment"># pubsub client buffer 限制</span></span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure></p><ul><li>client-output-buffer-limit normal 0 0 0</li></ul><p>将 hard limit 和 soft limit 同时设置为 0，则表示关闭该限制。</p><ul><li>client-output-buffer-limit slave 256mb 64mb 60</li></ul><p>该配置表示，对于 slave 客户端来说，如果 output-buffer 占用内存达到 256M 或者超过 64M 的时间达到 60s，则关闭客户端连接。</p><ul><li>client-output-buffer-limit pubsub 32mb 8mb 60</li></ul><p>该配置表示，对于 Pub/Sub 客户端来说，若 output-buffer 占用内存达到 32M 或者超过 8M 的时间达到 60s，则关闭客户端连接。</p><p><strong>概括说明：</strong><br>一般情况下，对于普通客户端，client-output-buffer 是不设限制的，因为 server 只会在 client 请求数据的时候才会发送，不会产生积压。<br>而在 server 主动发送，client 来处理的场景下，这种一般都是异步处理的，会划出一个缓冲区来“暂存”未处理的数据，若 server 发送数据比 client 处理数据快时，就会发生缓冲区积压。对于用作 Pub/Sub 和 slave 的客户端，server 会主动把数据推送给他们，故需要设置 client-output-buffer 的限制。</p><h1 id="示例分析"><a href="# 示例分析" class="headerlink" title="示例分析"></a>示例分析 </h1><p> 下面我们以主从同步时的 slave 客户端，来具体分析下。<br>在 redis 在主从同步时，master 会为 slave 创建一个输出缓冲区。在 master 保存 rdb，将 rdb 文件传输给 slave，slave 加载 rdb 完成之前，master 会将接收到的所有写命令，写入到内存中的这个输出缓冲区去。<br>若 rdb 的保存，传输，加载耗时过长，或者在此期间的写命令过多，则可能会造成超过缓冲区限制，造成 master 和 slave 的连接断开。此时则需要适当调整下 <code>client-output-buffer-limit slave</code>配置。</p><h1 id="源码浅析 - 主从同步时 -output-buffer- 使用"><a href="# 源码浅析 - 主从同步时 -output-buffer- 使用" class="headerlink" title="源码浅析 - 主从同步时 output buffer 使用"></a>源码浅析 - 主从同步时 output buffer 使用</h1><blockquote><p>基于 redis5.0 版本源码</p></blockquote><p>redis server 通过 addReply 将数据发送给客户端，以下源码见 <a href="https://github.com/redis/redis/blob/5.0/src/networking.c#L190-L211">https://github.com/redis/redis/blob/5.0/src/networking.c#L190-L211</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the object &#x27;obj&#x27; string representation to the client output buffer. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span><br><span class="line">            _addReplyStringToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">size_t</span> len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)</span><br><span class="line">            _addReplyStringToList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数的开头，会通过 <code>prepareClientToWrite(c)</code> 判断是否需要将数据写入客户端的 output buffer 中。我们看下什么条件下数据会被写入客户端的 output buffer 中，即返回 <code>C_OK</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called every time we are going to transmit new data</span></span><br><span class="line"><span class="comment"> * to the client. The behavior is the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the client should receive new data (normal clients will) the function</span></span><br><span class="line"><span class="comment"> * returns C_OK, and make sure to install the write handler in our event</span></span><br><span class="line"><span class="comment"> * loop so that when the socket is writable new data gets written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the client should not receive new data, because it is a fake client</span></span><br><span class="line"><span class="comment"> * (used to load AOF in memory), a master or because the setup of the write</span></span><br><span class="line"><span class="comment"> * handler failed, the function returns C_ERR.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function may return C_OK without actually installing the write</span></span><br><span class="line"><span class="comment"> * event handler in the following cases:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) The event handler should already be installed since the output buffer</span></span><br><span class="line"><span class="comment"> *    already contains something.</span></span><br><span class="line"><span class="comment"> * 2) The client is a slave but not yet online, so we want to just accumulate</span></span><br><span class="line"><span class="comment"> *    writes in the buffer but not actually sending them yet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Typically gets called every time a reply is built, before adding more</span></span><br><span class="line"><span class="comment"> * data to the clients output buffers. If the function returns C_ERR no</span></span><br><span class="line"><span class="comment"> * data should be appended to the output buffers. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* If it&#x27;s the Lua client we always return ok without installing any</span></span><br><span class="line"><span class="comment">     * handler since there is no socket at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CLIENT REPLY OFF / SKIP handling: don&#x27;t send replies. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Masters don&#x27;t receive replies, unless CLIENT_MASTER_FORCE_REPLY flag</span></span><br><span class="line"><span class="comment">     * is set. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;fd &lt;= <span class="number">0</span>) <span class="keyword">return</span> C_ERR; <span class="comment">/* Fake client for AOF loading. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Schedule the client to write the output buffers to the socket, unless</span></span><br><span class="line"><span class="comment">     * it should already be setup to do so (it has already pending data). */</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Authorize the caller to queue in the output buffer of this client. */</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return true if the specified client has pending reply buffers to write to</span></span><br><span class="line"><span class="comment"> * the socket. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clientHasPendingReplies</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;bufpos || listLength(c-&gt;reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Schedule the client to write the output buffers to the socket only</span></span><br><span class="line"><span class="comment">     * if not already done and, for slaves, if the slave can actually receive</span></span><br><span class="line"><span class="comment">     * writes at this stage. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE ||</span><br><span class="line">         (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</span><br><span class="line">    &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_WRITE;</span><br><span class="line">        listAddNodeHead(server.clients_pending_write,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于函数默认返回 <code>C_OK</code>，我们只需要看哪几类情况返回的不是<code>C_OK</code>，即<code>C_ERR</code>，数据就不会被写入到客户端的 output buffer 中。<br> 返回 <code>C_ERR</code> 的情况：</p><ul><li>客户端是个 fake client（用于加载 AOF 文件）</li><li>客户端是一个 master </li><li>slave 的状态为 SLAVE_STATE_ONLINE 且其回调函数失败（(c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)），或 slave 的状态为 REPL_STATE_NONE<blockquote><p>If the client should not receive new data, because it is a fake client (used to load AOF in memory), a master or because the setup of the write handler failed, the function returns C_ERR.</p></blockquote></li></ul><p>在 master 保存和发送 rdb 文件时，slave 的状态是以下几种，所以在这期间的写命令都会保存在 slave 的 output buffer。由于没有设置回调函数，数据并不会发送到 slave 上，仅存储在 master 为 slave 创建的 output buffer 内。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAVE_STATE_WAIT_BGSAVE_START 6 <span class="comment">/* We need to produce a new RDB file. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAVE_STATE_WAIT_BGSAVE_END 7 <span class="comment">/* Waiting RDB file creation to finish. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAVE_STATE_SEND_BULK 8 <span class="comment">/* Sending RDB file to slave. */</span></span></span><br></pre></td></tr></table></figure></p><p>那么何时才会从 output buffer 中“刷入”slave 呢？直到 master 将 rdb 文件完全发送给 slave 后，master 会在 <code>sendBulkToSlave</code>函数中进行相关操作。以下源码见：<a href="https://github.com/redis/redis/blob/5.0/src/replication.c#L876-L930">https://github.com/redis/redis/blob/5.0/src/replication.c#L876-L930</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendBulkToSlave</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略部分源码 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rdb 文件已完全发送给 slave </span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;repldboff == slave-&gt;repldbsize) &#123;</span><br><span class="line">        close(slave-&gt;repldbfd);</span><br><span class="line">        slave-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">        aeDeleteFileEvent(server.el,slave-&gt;fd,AE_WRITABLE);</span><br><span class="line">        putSlaveOnline(slave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putSlaveOnline</span><span class="params">(client *slave)</span> </span>&#123;</span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">    slave-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    slave-&gt;repl_ack_time = server.unixtime; <span class="comment">/* Prevent false timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, slave-&gt;fd, AE_WRITABLE,</span><br><span class="line">        sendReplyToClient, slave) == AE_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unable to register writable event for replica bulk transfer: %s&quot;</span>, strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Synchronization with replica %s succeeded&quot;</span>,</span><br><span class="line">        replicationGetSlaveName(slave));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 此处会将 slave 状态改为 <code>SLAVE_STATE_ONLINE</code>，并将 <code>repl_put_online_on_ack</code> 置为 0，（有没有很熟悉，对了，就是上面 <code>clientInstallWriteHandler</code> 中判断的内容）。同时也会设置回调函数<code>sendReplyToClient</code>，将此前 master 为 slave 创建的 output buffer 中的写操作全部发送到 slave 上。同时 slave 状态的变更，会使得后续 master 上的写操作可以正常的 push 到 slave 上了（直接，无需走 output buffer）。</p><h1 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h1><p> 本次我们通过 <code>client-output-buffer-limit</code>参数，了解了其使用场景，并重点就主从同步时 output buffer 写入情况进行了源码的简单分析。今天的学习就到这里，我们改天接着肝。</p><h1 id="参考内容"><a href="# 参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ol><li><a href="https://www.cnblogs.com/wangcp-2014/p/15505180.html">https://www.cnblogs.com/wangcp-2014/p/15505180.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis 的 client-output-buffer-limit 可以用来强制断开无法足够快从 redis 服务器端读取数据的客户端。&lt;br&gt;保护机制规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[hard limit] 大小限制，当某一客户端缓冲区超过设定值后，直接关闭连接。&lt;/li&gt;
&lt;li&gt;[soft limit] 持续时间限制，当某一客户端缓冲区持续一段时间占用过大空间时关闭连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该参数一般用在以下几类客户端中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通 client，包括 monitor&lt;/li&gt;
&lt;li&gt;主从同步时的 slave client&lt;/li&gt;
&lt;li&gt;Pub/Sub 模式中的 client&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.immaxfang.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.immaxfang.com/tags/redis/"/>
    
      <category term="源码" scheme="http://www.immaxfang.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>API 的 Authorization 头里为啥有个 Bearer</title>
    <link href="http://www.immaxfang.com/authorization-header/"/>
    <id>http://www.immaxfang.com/authorization-header/</id>
    <published>2022-09-04T16:33:48.000Z</published>
    <updated>2023-01-24T05:58:38.540Z</updated>
    
    <content type="html"><![CDATA[<p> 在我们设计和使用 API 授权的时候，经常会接触到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization : Bearer Tokenxxxxxx</span><br></pre></td></tr></table></figure><p> 为什么前面会有个 Bearer，直接弄成这样不是更简单么。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization : Tokenxxxxxx</span><br></pre></td></tr></table></figure><p> 这是因为 W3C 的 HTTP 1.0 规范，具体见 10.2 和 11 。Authorization 的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: &lt;<span class="built_in">type</span>&gt; &lt;authorization-parameters&gt;</span><br></pre></td></tr></table></figure><p>Bearer 是授权的类型，常见的授权类型有：</p><ul><li>Basic 用于 http-basic 认证；</li><li>Bearer 常见于 OAuth 和 JWT 授权；</li><li>Digest MD5 哈希的 http-basic 认证 (已弃用)</li><li>AWS4-HMAC-SHA256 AWS 授权 </li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们设计和使用API授权的时候，经常会接触到如下内容：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Authorization : Bearer Tokenxxxxxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为什么前面会有个Bearer，直接弄成这样不是更简单么。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【Prometheus+Grafana 系列】监控 MySQL 服务</title>
    <link href="http://www.immaxfang.com/prometheus-grafana-mysql/"/>
    <id>http://www.immaxfang.com/prometheus-grafana-mysql/</id>
    <published>2022-08-24T04:26:08.000Z</published>
    <updated>2023-01-24T05:56:53.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 前面的一篇文章已经介绍了 docker-compose 搭建 Prometheus + Grafana 服务。当时实现了监控服务器指标数据，是通过 node_exporter。Prometheus 还可用来监控很多服务，比如常见的  MySQL。本文就介绍如何通过 mysqld_exporter 来监控 MySQL 指标。</p><h2 id="下载安装包"><a href="# 下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https:<span class="comment">//github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz</span></span><br><span class="line">tar xvf mysqld_exporter-<span class="number">0.14</span>.<span class="number">0</span>.linux-amd64.tar.gz</span><br><span class="line">mv mysqld_exporter-<span class="number">0.14</span>.<span class="number">0</span>.linux-amd64 mysqld_exporter</span><br><span class="line">mv /opt/mysqld_exporter /usr/local/</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="创建监控账号并授权"><a href="# 创建监控账号并授权" class="headerlink" title="创建监控账号并授权"></a>创建监控账号并授权 </h2><p> 在需要监控的 mysql 上创建账号并授权。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">CREATE USER <span class="string">&#x27;prometheus&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;prometheus&#x27;</span>;</span><br><span class="line"><span class="comment"># 分配权限</span></span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO <span class="string">&#x27;prometheus&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></p><h2 id="添加数据库监控账号配置"><a href="# 添加数据库监控账号配置" class="headerlink" title="添加数据库监控账号配置"></a>添加数据库监控账号配置 </h2><p>vim /usr/local/mysqld_exporter/.my.cnf<br> 添加如下内容<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">user=prometheus</span><br><span class="line">password=prometheus</span><br><span class="line">port=<span class="number">3306</span></span><br></pre></td></tr></table></figure></p><h2 id="启动 exporter 客户端"><a href="# 启动 exporter 客户端" class="headerlink" title="启动 exporter 客户端"></a>启动 exporter 客户端</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnf</span><br></pre></td></tr></table></figure><p>先手动启动 exporter 看一下日志，若有错误根据输出调整即可。手动运行没问题后，则进行下一步将其添加到系统服务中。</p><h2 id="添加到系统服务"><a href="# 添加到系统服务" class="headerlink" title="添加到系统服务"></a>添加到系统服务 </h2><p>vim /etc/systemd/system/mysqld_exporter.service<br> 添加如下内容<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mysqld_exporter</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/mysqld_exporter/mysqld_exporter --config.my-cnf=/usr/local/mysqld_exporter/.my.cnf</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><h2 id="加载并重启服务"><a href="# 加载并重启服务" class="headerlink" title="加载并重启服务"></a>加载并重启服务</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl restart mysqld_exporter.service</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status mysqld_exporter.service</span><br><span class="line"><span class="comment"># 配置开机启动</span></span><br><span class="line">systemctl enable mysqld_exporter.service</span><br></pre></td></tr></table></figure><h2 id="查看收集数据"><a href="# 查看收集数据" class="headerlink" title="查看收集数据"></a>查看收集数据 </h2><p> 访问 exporter 服务地址，查看数据收集情况。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//192.168.2.192:9104/metrics</span></span><br></pre></td></tr></table></figure></p><h2 id="修改 -prometheus- 配置文件，添加新节点"><a href="# 修改 -prometheus- 配置文件，添加新节点" class="headerlink" title="修改 prometheus 配置文件，添加新节点"></a>修改 prometheus 配置文件，添加新节点 </h2><p> 修改 prometheus 下的配置，prometheus.yml，添加如下内容。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scrape_configs:  </span><br><span class="line">  <span class="comment"># 添加 job</span></span><br><span class="line">  - job_name: <span class="string">&#x27;mysql-192&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">     <span class="comment"># 配置监控端，即上面我们启动的 mysqld_exporter 服务</span></span><br><span class="line">     - targets: [<span class="string">&#x27;192.168.2.192:9104&#x27;</span>]</span><br><span class="line">       labels:</span><br><span class="line">          instance: mysql</span><br></pre></td></tr></table></figure></p><h2 id="重启 -prometheus- 服务"><a href="# 重启 -prometheus- 服务" class="headerlink" title="重启 prometheus 服务"></a>重启 prometheus 服务 </h2><p> 上一步修改了 prometheus.yml，需要重启下 prometheus 服务。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /<span class="keyword">var</span>/workspace/docker-prometheus</span><br><span class="line">docker-compose stop prometheus</span><br><span class="line">docker-compose up -d --build prometheus</span><br></pre></td></tr></table></figure></p><h2 id="查看 -prometheus- 中服务添加情况"><a href="# 查看 -prometheus- 中服务添加情况" class="headerlink" title="查看 prometheus 中服务添加情况"></a>查看 prometheus 中服务添加情况 </h2><p> 查看 targets 是否添加成功<br><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-1.png" alt="image.png"></p><p>查看 mysql 监控信息</p><blockquote><p>mysql_global_status_aborted_clients</p></blockquote><p><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-2.png" alt="image.png"></p><h2 id="在 -grafana- 中添加 -data-sources"><a href="# 在 -grafana- 中添加 -data-sources" class="headerlink" title="在 grafana 中添加 data sources"></a>在 grafana 中添加 data sources</h2><p><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-3.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-4.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-5.png" alt="image.png"><br>添加 prometheus 服务地址，此处由于服务是基于 docker-compose 构建的，没有填写 ip，直接填写服务名即可。</p><h2 id="在 -grafana- 中导入 -mysql- 监控"><a href="# 在 -grafana- 中导入 -mysql- 监控" class="headerlink" title="在 grafana 中导入 mysql 监控"></a>在 grafana 中导入 mysql 监控 </h2><p><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-6.png" alt="image.png"><br> 输入官方模版 id，7362，点击 load。然后按照下图选择确认即可。<br><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-7.png" alt="image.png"></p><h2 id="监控展示"><a href="# 监控展示" class="headerlink" title="监控展示"></a>监控展示 </h2><p> 上一步导入成功后，会自动跳转到监控面板页面，如下图。默认的格式已经非常丰富可以直接使用了，也可以根据自己需求调整位置和配置。<br><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/post-pgm-8.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的一篇文章已经介绍了 docker-compose 搭建 Prometheus + Grafana 服务。当时实现了监控服务器指标数据，是通过 node_exporter。Prometheus 还可用来监控很多服务，比如常见的  MySQL。本文就介绍如何通过 mysqld_exporter 来监控 MySQL 指标。&lt;/p&gt;
&lt;h2 id=&quot;下载安装包&quot;&gt;&lt;a href=&quot;#下载安装包&quot; class=&quot;headerlink&quot; title=&quot;下载安装包&quot;&gt;&lt;/a&gt;下载安装包&lt;/h2&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /opt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https:&lt;span class=&quot;comment&quot;&gt;//github.com/prometheus/mysqld_exporter/releases/download/v0.14.0/mysqld_exporter-0.14.0.linux-amd64.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar xvf mysqld_exporter-&lt;span class=&quot;number&quot;&gt;0.14&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.linux-amd64.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv mysqld_exporter-&lt;span class=&quot;number&quot;&gt;0.14&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.linux-amd64 mysqld_exporter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv /opt/mysqld_exporter /usr/local/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="运维" scheme="http://www.immaxfang.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://www.immaxfang.com/tags/Linux/"/>
    
      <category term="devops" scheme="http://www.immaxfang.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>【Prometheus+Grafana 系列】基于 docker-compose 搭建</title>
    <link href="http://www.immaxfang.com/prometheus-grafana-docker-compose-build/"/>
    <id>http://www.immaxfang.com/prometheus-grafana-docker-compose-build/</id>
    <published>2022-08-23T14:40:33.000Z</published>
    <updated>2023-01-24T05:57:02.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>Prometheus 是有 SoundCloud 开发的开源监控系统和时序数据库，基于 Go 语言开发。通过基于 HTTP 的 pull 方式采集时序数据，通过服务发现或静态配置去获取要采集的目标服务器，支持多节点工作，支持多种可视化图表及仪表盘。<br> 贴一下官方提供的架构图：<br><img src="https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/pgd-1.png" alt="image.png"></p><p>Pormetheus 几个主要模块有，Server，Exporters，Pushgateway，PromQL，Alertmanager，WebUI 等，主要逻辑如下：</p><ul><li>Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。</li><li>当新拉取的数据大于配置内存缓存区时，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。</li><li>Prometheus 配置 rules，然后定时查询数据，当条件触发时，会将 alert 推送到配置的 Alertmanager。</li><li>Alertmanager 收到警告时，会根据配置，聚合、去重、降噪等操作，最后发送警告。</li><li>可以使用 API，Prometheus Console 或者 Grafana 查询和聚合数据。</li></ul><span id="more"></span><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana 是一个开源的度量分析及可视化套件。通过访问数据库（如 InfluxDB、Prometheus），展示自定义图表。</p><h2 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h2><p>Exporter 是 Prometheus 推出的针对服务器状态监控的 Metrics 工具。目前开发中常见的组件都有对应的 exporter 可以直接使用。常见的有两大类，一种是社区提供的，包含数据库，消息队列，存储，HTTP 服务，日志等，比如 node_exporter，mysqld_exporter 等；还有一种是用户自定义的 exporter，可以基于官方提供的 Client Library 创建自己的 exporter 程序。<br>每个 exporter 的一个实例被称为 target，Prometheus 通过轮询的方式定期从这些 target 中获取样本数据。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-2.png" alt="image.png"></p><h2 id="原理简介"><a href="# 原理简介" class="headerlink" title="原理简介"></a>原理简介</h2><p><img src="https://cdn.immaxfang.com/images/post/2022/pgd-3.png" alt="image.png"></p><h1 id="安装数据收集器 -node-exporter"><a href="# 安装数据收集器 -node-exporter" class="headerlink" title="安装数据收集器 node-exporter"></a>安装数据收集器 node-exporter</h1><h2 id="安装 -node-exporter"><a href="# 安装 -node-exporter" class="headerlink" title="安装 node-exporter"></a>安装 node-exporter</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /opt</span><br><span class="line">wget https:<span class="comment">//github.com/prometheus/node_exporter/releases/download/v1.4.0-rc.0/node_exporter-1.4.0-rc.0.linux-amd64.tar.gz</span></span><br><span class="line">tar xvf node_exporter-<span class="number">1.4</span>.<span class="number">0</span>-rc.<span class="number">0</span>.linux-amd64.tar.gz</span><br><span class="line">mv node_exporter-<span class="number">1.4</span>.<span class="number">0</span>-rc.<span class="number">0</span>.linux-amd64 node_exporter</span><br><span class="line">mv node_exporter /usr/local/</span><br></pre></td></tr></table></figure><p>运行如下命令测试 node-exporter 收集器启动情况，正常情况下会输出服务端口。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/node_exporter/node_exporter</span><br></pre></td></tr></table></figure></p><h2 id="添加到系统服务"><a href="# 添加到系统服务" class="headerlink" title="添加到系统服务"></a>添加到系统服务 </h2><p>vim /etc/systemd/system/node_exporter.service<br> 添加如下内容<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=mysqld_exporter</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><h2 id="加载并重启服务"><a href="# 加载并重启服务" class="headerlink" title="加载并重启服务"></a>加载并重启服务</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl restart node_exporter.service</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status node_exporter.service</span><br><span class="line"><span class="comment"># 配置开机启动</span></span><br><span class="line">systemctl enable node_exporter.service</span><br></pre></td></tr></table></figure><h2 id="查看数据收集情况"><a href="# 查看数据收集情况" class="headerlink" title="查看数据收集情况"></a>查看数据收集情况 </h2><p> 重新起一个终端，查看数据收集情况。也可以在浏览器中查看。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//127.0.0.1:9100/metrics</span></span><br></pre></td></tr></table></figure></p><h1 id="安装 -prometheus- 和 -grafana"><a href="# 安装 -prometheus- 和 -grafana" class="headerlink" title="安装 prometheus 和 grafana"></a>安装 prometheus 和 grafana</h1><h2 id="安装 -docker-amp-docker-compose"><a href="# 安装 -docker-amp-docker-compose" class="headerlink" title="安装 docker&amp;docker-compose"></a>安装 docker&amp;docker-compose</h2><p>本文介绍的安装方法是基于 docker-compose 的，所以需要先安装相关 docker 环境。相关方法可以见笔者的其他文章，本文中不做详细介绍。</p><h2 id="安装 -prometheus- 和 -grafana-1"><a href="# 安装 -prometheus- 和 -grafana-1" class="headerlink" title="安装 prometheus 和 grafana"></a>安装 prometheus 和 grafana</h2><p>可以直接 clone 这个项目来快速搭建：<br><a href="https://github.com/FX-Max/docker-install-everything/tree/master/prometheus">https://github.com/FX-Max/docker-install-everything/tree/master/prometheus</a></p><blockquote><p>该项目是笔者弄的一个使用 docker-compose 搭建软件开发常见服务的项目，大家觉得有帮助，可以帮忙点个 star，感谢。</p></blockquote><p>根据实际情况，修改 prometheus.yml 文件中的内容，将 ip 修改为上面安装了 node-exporter 的服务器 ip 即可。<br>然后在该目录下执行 <code>docker-compose up -d</code>即可，<code>docker ps</code>查看服务启动情况。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE              COMMAND                  CREATED        STATUS        PORTS                                      NAMES</span><br><span class="line"><span class="number">6</span>f360e9ab242   grafana/grafana    <span class="string">&quot;/run.sh&quot;</span>                <span class="number">25</span> hours ago   Up <span class="number">25</span> hours   <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">3000</span>-&gt;<span class="number">3000</span>/tcp, :::<span class="number">3000</span>-&gt;<span class="number">3000</span>/tcp  grafana</span><br><span class="line"><span class="number">97</span>b92b65aca6   prom/prometheus    <span class="string">&quot;/bin/prometheus --c…&quot;</span>   <span class="number">25</span> hours ago   Up <span class="number">21</span> hours   <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9090</span>-&gt;<span class="number">9090</span>/tcp, :::<span class="number">9090</span>-&gt;<span class="number">9090</span>/tcp  prometheus</span><br><span class="line"><span class="number">3</span>f5906f07bf6   prom/pushgateway   <span class="string">&quot;/bin/pushgateway&quot;</span>       <span class="number">25</span> hours ago   Up <span class="number">25</span> hours   <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9091</span>-&gt;<span class="number">9091</span>/tcp, :::<span class="number">9091</span>-&gt;<span class="number">9091</span>/tcp  pushgateway</span><br><span class="line">f556168c1b8b   prom/alertmanager  <span class="string">&quot;/bin/alertmanager -…&quot;</span>   <span class="number">25</span> hours ago   Up <span class="number">25</span> hours   <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9093</span>-&gt;<span class="number">9093</span>/tcp, :::<span class="number">9093</span>-&gt;<span class="number">9093</span>/tcp  alertmanager</span><br></pre></td></tr></table></figure><br>docker-compose.yml 内容：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  prometheus:</span><br><span class="line">    image: prom/prometheus</span><br><span class="line">    container_name: prometheus</span><br><span class="line">    user: root</span><br><span class="line"><span class="comment">#    restart: always</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;9090:9090&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./conf/prometheus:/etc/prometheus</span><br><span class="line">      - ./data/prometheus/prometheus_db:/prometheus </span><br><span class="line">    command:</span><br><span class="line">      - <span class="string">&#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;</span></span><br><span class="line">      - <span class="string">&#x27;--storage.tsdb.path=/prometheus&#x27;</span></span><br><span class="line">      - <span class="string">&#x27;--web.console.libraries=/usr/share/prometheus/console_libraries&#x27;</span></span><br><span class="line">      - <span class="string">&#x27;--web.console.templates=/usr/share/prometheus/consoles&#x27;</span></span><br><span class="line">    networks:</span><br><span class="line">      - net-prometheus</span><br><span class="line"></span><br><span class="line">  grafana:</span><br><span class="line">    image: grafana/grafana</span><br><span class="line">    container_name: grafana</span><br><span class="line">    user: root</span><br><span class="line"><span class="comment">#    restart: always</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      <span class="comment">#- ./conf/grafana:/etc/grafana</span></span><br><span class="line">      - ./data/prometheus/grafana_data:/<span class="keyword">var</span>/lib/grafana</span><br><span class="line">    depends_on:  </span><br><span class="line">      - prometheus</span><br><span class="line">    networks:</span><br><span class="line">      - net-prometheus</span><br><span class="line"></span><br><span class="line">  pushgateway:</span><br><span class="line">    image: prom/pushgateway</span><br><span class="line">    container_name: pushgateway</span><br><span class="line">    user: root</span><br><span class="line"><span class="comment">#    restart: always</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;9091:9091&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/prometheus/pushgateway_data:/<span class="keyword">var</span>/lib/pushgateway</span><br><span class="line"></span><br><span class="line">  alertmanager:</span><br><span class="line">    image: prom/alertmanager</span><br><span class="line">    hostname: alertmanager</span><br><span class="line">    container_name: alertmanager</span><br><span class="line">    user: root</span><br><span class="line"><span class="comment">#    restart: always</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;9093:9093&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/prometheus/alertmanager_data:/<span class="keyword">var</span>/lib/alertmanager</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  net-prometheus:</span><br></pre></td></tr></table></figure><br>prometheus.yml 内容：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  scrape_interval:     <span class="number">5</span>s</span><br><span class="line">  evaluation_interval: <span class="number">5</span>s</span><br><span class="line"></span><br><span class="line">  external_labels:</span><br><span class="line">      monitor: <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line"></span><br><span class="line">alerting:</span><br><span class="line"> alertmanagers:</span><br><span class="line"> - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">        - <span class="string">&quot;alertmanager:9093&quot;</span></span><br><span class="line"></span><br><span class="line">rule_files:</span><br><span class="line">  <span class="comment">#- &#x27;alert.rules&#x27;</span></span><br><span class="line"></span><br><span class="line">scrape_configs:  </span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    scrape_interval: <span class="number">5</span>s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;prometheus:9090&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  - job_name: node</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">&#x27;192.168.0.103:9100&#x27;</span>,<span class="string">&#x27;pushgateway:9091&#x27;</span>]</span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">&#x27;mysql-131&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">     - targets: [<span class="string">&#x27;192.168.0.131:9104&#x27;</span>]</span><br><span class="line">       labels:</span><br><span class="line">          instance: mysql</span><br></pre></td></tr></table></figure></p><h2 id="查看 -prometheus"><a href="# 查看 -prometheus" class="headerlink" title="查看 prometheus"></a>查看 prometheus</h2><p>访问 <code>http://127.0.0.1:9090/targets</code>，效果如下，上面我们通过 node_exporter 收集的节点状态是 up 状态。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-4.png" alt="image.png"></p><h2 id="配置 -Grafana"><a href="# 配置 -Grafana" class="headerlink" title="配置 Grafana"></a>配置 Grafana</h2><p>访问 <code>http://127.0.0.1:3000</code>，登录 Grafana，默认的账号密码是 admin:admin，首次登录需要修改默认密码。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-5.png" alt="image.png"></p><p>按照如下添加 data sources，将 prometheus 添加到 data sources 中。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-6.png" alt="image.png"><br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-7.png" alt="image.png"><br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-8.png" alt="image.png"><br>添加 prometheus 服务地址，此处由于服务是基于 docker-compose 构建的，没有填写 ip，直接填写服务名即可。</p><h2 id="添加监控模版"><a href="# 添加监控模版" class="headerlink" title="添加监控模版"></a>添加监控模版</h2><p><img src="https://cdn.immaxfang.com/images/post/2022/pgd-9.png" alt="image.png"></p><p>输入官方模版 id，1860，点击 load。然后按照下图选择确认即可。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-10.png" alt="image.png"></p><p>导入成功后，会自动跳转到监控面板页面，如下图。<br><img src="https://cdn.immaxfang.com/images/post/2022/pgd-11.png" alt="image.png"></p><h1 id="结语"><a href="# 结语" class="headerlink" title="结语"></a>结语 </h1><p> 本文简单介绍了 prometheus + grafana 服务搭建流程，初步跑通了整个服务。当然它还有很多功能，后续笔者会开新的文章来分享。</p><h2 id="参考文档"><a href="# 参考文档" class="headerlink" title="参考文档"></a>参考文档 </h2><p> 官方模板库：<a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a><br>node 模板：<a href="https://grafana.com/grafana/dashboards/1860">https://grafana.com/grafana/dashboards/1860</a><br>MySQL 模板：<a href="https://grafana.com/grafana/dashboards/7362">https://grafana.com/grafana/dashboards/7362</a><br>docker 搭建 prometheus&amp;grafana：<a href="https://blog.51cto.com/keep11/4261521">https://blog.51cto.com/keep11/4261521</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;Prometheus&quot;&gt;&lt;a href=&quot;#Prometheus&quot; class=&quot;headerlink&quot; title=&quot;Prometheus&quot;&gt;&lt;/a&gt;Prometheus&lt;/h2&gt;&lt;p&gt;Prometheus 是有 SoundCloud 开发的开源监控系统和时序数据库，基于 Go 语言开发。通过基于 HTTP 的 pull 方式采集时序数据，通过服务发现或静态配置去获取要采集的目标服务器，支持多节点工作，支持多种可视化图表及仪表盘。&lt;br&gt;贴一下官方提供的架构图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/FX-Max/cdn/master/blog/post/2022/pgd-1.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Pormetheus 几个主要模块有，Server，Exporters，Pushgateway，PromQL，Alertmanager，WebUI等，主要逻辑如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。&lt;/li&gt;
&lt;li&gt;当新拉取的数据大于配置内存缓存区时，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。&lt;/li&gt;
&lt;li&gt;Prometheus 配置 rules，然后定时查询数据，当条件触发时，会将 alert 推送到配置的 Alertmanager。&lt;/li&gt;
&lt;li&gt;Alertmanager 收到警告时，会根据配置，聚合、去重、降噪等操作，最后发送警告。&lt;/li&gt;
&lt;li&gt;可以使用 API，Prometheus Console 或者 Grafana 查询和聚合数据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="运维" scheme="http://www.immaxfang.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://www.immaxfang.com/tags/Linux/"/>
    
      <category term="devops" scheme="http://www.immaxfang.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>日志规范实践</title>
    <link href="http://www.immaxfang.com/talking-log-specification/"/>
    <id>http://www.immaxfang.com/talking-log-specification/</id>
    <published>2022-07-25T10:28:30.000Z</published>
    <updated>2023-01-24T05:57:52.887Z</updated>
    
    <content type="html"><![CDATA[<p>日志与我们日常的项目开发有着密切关系，日志是我们分析和排查问题的重要依据。今天就来简单总结下笔者个人对于项目中日志的一些经验。</p><h1 id="1- 日志文件规范"><a href="#1- 日志文件规范" class="headerlink" title="1. 日志文件规范"></a>1. 日志文件规范 </h1><h2 id="1-1 日志文件命名"><a href="#1-1 日志文件命名" class="headerlink" title="1.1 日志文件命名"></a>1.1 日志文件命名</h2><p> 日志文件名格式：logname_YY-MM-dd_hh.[roll-count].log<br>例子：api_2022-06-20_12.0.log</p><span id="more"></span><h2 id="1-2 日志滚动大小"><a href="#1-2 日志滚动大小" class="headerlink" title="1.2 日志滚动大小"></a>1.2 日志滚动大小 </h2><p> 一般要限制每个日记文件的大小，需日志滚动。一般常设置文件大小为 100M。<br>Linux 对于小文件存在 Inodes 限制，所以当日志量大时，日志文件大小不宜设置的过小，否则将会产生大量日志滚动，造成日志文件过多，造成 Inodes 报警。并且最好定期清理过期的日志文件。</p><h2 id="1-3 日志文件存放位置"><a href="#1-3 日志文件存放位置" class="headerlink" title="1.3 日志文件存放位置"></a>1.3 日志文件存放位置 </h2><p> 日志文件统一保存在服务器的目录中，这个目录在团队内部最好是固定的，且有一定规律。<br>例如日志的根目录均为 <code>/data/logs</code>，项目的日志可以放在<code>/data/logs/app/order-service/</code> 目录下，nginx 的日志可以放在 <code>/data/logs/service/nginx/</code> 目录下面。<br>统一的日志存放路径便于后续接入日志平台与运维自动化，否则日志采集程序需要定义不同的日志路径，这将是一件非常复杂且不利于维护的事情。</p><h1 id="2- 日志内容规范"><a href="#2- 日志内容规范" class="headerlink" title="2. 日志内容规范"></a>2. 日志内容规范 </h1><h2 id="2-1 模块编号 -app-id"><a href="#2-1 模块编号 -app-id" class="headerlink" title="2.1 模块编号(app_id)"></a>2.1 模块编号(app_id)</h2><p> 为每个模块或组件分配一个编号，即 app_id，该值需要全局唯一，便于在 ELK 等日志平台检索指定业务模块的日志。</p><h2 id="2-2 时间戳 -timestamp"><a href="#2-2 时间戳 -timestamp" class="headerlink" title="2.2 时间戳 (@timestamp)"></a>2.2 时间戳(@timestamp)</h2><p> 日志产生的时间，建议使用 Time_ISO8601。其中，yyyy 代表四位数年份，MM 代表两位数月份，dd 代表两位数日期，HH 代表两位数小时时间，mm 代表两位数分钟时间，ss 代表两位数秒时间，Time_zone 代表时区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@timestamp=<span class="string">&quot;yyyy-MM-ddTHH:mm:ss+Time_zone&quot;</span></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">@timestamp=<span class="string">&quot;2022-06-20T03:01:15+08:00&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-3 日志级别 -level"><a href="#2-3 日志级别 -level" class="headerlink" title="2.3 日志级别(level)"></a>2.3 日志级别(level)</h2><table><thead><tr><th><strong>日志级别</strong></th><th><strong>描述</strong></th><th><strong>类别</strong></th></tr></thead><tbody><tr><td>FATAL</td><td>业务软件发生严重错误，服务被终止或重启，需立即被处理。</td><td>错误信息日志</td></tr><tr><td>ERROR</td><td>业务软件发生错误，后续流程还能继续进行，但已经影响用户正常访问。该级别错误也需要马上被处理。</td><td>错误信息日志</td></tr><tr><td>WARN</td><td>有潜在风险、不会造成大危害的错误，需开发人员关注，一般是程序逻辑缺陷。</td><td>错误信息日志</td></tr><tr><td>INFO</td><td>在正常运行状态中，粗粒度的、关键流程或事件、业务软件重要的配置和参数信息，可用来表示业务软件健康度的信息。</td><td>一般信息日志</td></tr><tr><td>DEBUG</td><td>对调试有帮助的信息或事件，默认情况下不打开日志记录。</td><td>调试信息日志</td></tr></tbody></table><p>按照业务要求，打开合适级别的日志记录。同时在代码中记录日志时，level 也要评估好。禁止乱使用 level，无用的数据打入日志。</p><h2 id="2-4 日志格式与字段"><a href="#2-4 日志格式与字段" class="headerlink" title="2.4 日志格式与字段"></a>2.4 日志格式与字段 </h2><p> 一般使用 json 格式，主流日志分析平台都支持，且各种程序语言对于 json 格式日志写入也都有很好的库支持。<br>每条业务日志必须包含的字段： app_id，@timestamp，level。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@timestamp&quot;</span>: <span class="string">&quot;2022-06-20T03:01:15+08:00&quot;</span>, <span class="string">&quot;app_id&quot;</span>: <span class="string">&quot;DFNAKLPYH&quot;</span>, <span class="string">&quot;level&quot;</span>: <span class="string">&quot;INFO&quot;</span>, ....&#125;</span><br></pre></td></tr></table></figure><p>对于多系统间调用，还需要至少包含 trace_id 标识，一次完整的调用链路需要传递并记录唯一的 trace_id。</p><h2 id="2-5 日志安全"><a href="#2-5 日志安全" class="headerlink" title="2.5 日志安全"></a>2.5 日志安全 </h2><p> 对可能含有敏感信息的文本打入日志要保持敬畏。同时对于进入日志中的敏感信息，要在日志采集器或者日志平台中进行脱敏处理，避免其出现在日志检索中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志与我们日常的项目开发有着密切关系，日志是我们分析和排查问题的重要依据。今天就来简单总结下笔者个人对于项目中日志的一些经验。&lt;/p&gt;
&lt;h1 id=&quot;1-日志文件规范&quot;&gt;&lt;a href=&quot;#1-日志文件规范&quot; class=&quot;headerlink&quot; title=&quot;1.日志文件规范&quot;&gt;&lt;/a&gt;1.日志文件规范&lt;/h1&gt;&lt;h2 id=&quot;1-1日志文件命名&quot;&gt;&lt;a href=&quot;#1-1日志文件命名&quot; class=&quot;headerlink&quot; title=&quot;1.1日志文件命名&quot;&gt;&lt;/a&gt;1.1日志文件命名&lt;/h2&gt;&lt;p&gt;日志文件名格式：logname_YY-MM-dd_hh.[roll-count].log&lt;br&gt;例子：api_2022-06-20_12.0.log&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单易用的任务队列 -beanstalkd</title>
    <link href="http://www.immaxfang.com/beanstalkd/"/>
    <id>http://www.immaxfang.com/beanstalkd/</id>
    <published>2022-07-15T13:14:27.000Z</published>
    <updated>2023-01-24T05:58:51.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述</h1><p>beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 TCP 上。其最初设计的目的是通过后台异步执行耗时任务的方式降低高容量 Web 应用的页面延时。其具有简单、轻量、易用等特点，也支持对任务优先级、延时 / 超时重发等控制，同时还有众多语言版本的客户端支持，这些优点使得它成为各种需要队列系统场景的一种常见选择。</p><h2 id="beanstalkd- 优点"><a href="#beanstalkd- 优点" class="headerlink" title="beanstalkd 优点"></a>beanstalkd 优点</h2><ul><li>如他官网的介绍，simple&amp;fast，使用非常简单，适合需要引入消息队列又不想引入 kafka 这类重型的 mq，维护成本低；同时，它的性能非常高，大部分场景下都可以 cover 住。</li><li>支持持久化</li><li>支持消息优先级，topic，延时消息，消息重试等</li><li>主流语言客户端都支持，还可以根据 beanstalkd 协议自行实现。</li></ul><span id="more"></span><h2 id="beanstalkd- 不足"><a href="#beanstalkd- 不足" class="headerlink" title="beanstalkd 不足"></a>beanstalkd 不足</h2><ul><li>无最大内存控制，当业务消息极多时，服务可能会不稳定。</li><li>官方没有提供集群故障切换方案(主从或哨兵等)，需要自己解决。</li></ul><h1 id="beanstalkd- 重点概念"><a href="#beanstalkd- 重点概念" class="headerlink" title="beanstalkd 重点概念"></a>beanstalkd 重点概念</h1><ul><li>job</li></ul><p>任务，队列中的基本单元，每个 job 都会有 id 和优先级。有点类似其他消息队列中的 message 的概念。但 job 有各种状态，下文介绍生命周期部分会重点介绍。job 存放在 tube 中。</p><ul><li>tube</li></ul><p>管道，用来存储同一类型的 job。有点类似其他消息队列中的 topic 的概念。beanstalkd 通过 tube 来实现多任务队列，beanstalkd 中可以有多个管道，每个管道有自己的 producer 和 consumer，管道之间互相不影响。</p><ul><li>producer</li></ul><p>job 生产者。通过 put 命令将一个 job 放入到一个 tube 中。</p><ul><li>consumer</li></ul><p>job 消费者。通过 reserve 来获取 job，通过 delete、release、bury 来改变 job 的状态。</p><h1 id="beanstalkd- 生命周期"><a href="#beanstalkd- 生命周期" class="headerlink" title="beanstalkd 生命周期"></a>beanstalkd 生命周期 </h1><p> 上文介绍到，beanstalkd 中 job 有状态区分，在整个生命周期中，job 可能有四种状态：<code>READY</code>, <code>RESERVED</code>, <code>DELAYED</code>, <code>BURIED</code>。只有处于 <code>READY</code> 状态的 job 才能被消费。下图介绍了各状态之间的流转情况。</p><p><img src="https://cdn.immaxfang.com/images/post/2022/beanstalkd-status.png" alt="beanstalkd-status"></p><p>producer 在创建 job 的时候有两种方式，put 和 put with delay（延时任务）。<br>如果 producer 使用 put 直接创建一个 job 时，该 job 就处于 READY 状态，等待 consumer 处理。<br>如果 producer 使用 put with delay 方式创建 job，该 job 的初始状态为 DELAYED 状态，等待延迟时间过后才变更为 READY 状态。<br>以上两种方式创建的 job 都会传入一个 TTR（超时机制），当 job 处于 RESERVED 状态时，TTR 开始倒计时，当 TTR 倒计时完，job 状态还没有改变，则会认为该 job 处理失败，会被重新放回到队列中。</p><p>consumer 获取到（reserve）一个 READY 状态的 job 之后，该 job 的状态就会变更为 RESERVED。此时，其他的 consumer 就不能再操作该 job 了。当 consumer 完成该 job 之后，可以选择 delete，release，或 bury 操作。</p><ul><li>delete ，job 被删除，从 beanstalkd 中清除，以后也无法再获取到，生命周期结束。</li><li>release ，可以把该 job 重新变更为 READY 状态，使得其他的 consumer 可以继续获取和执行该 job，也可以使用 release with delay 延时操作，这样会先进入 DELAYED 状态，延迟时间到达后再变为 READY。</li><li>bury，可以将 job 休眠，等需要的时候，在将休眠的 job 通过 kick 命令变更回 READY 状态，也可以通过 delete 直接删除 BURIED 状态的 job 。</li></ul><p>处于 BURIED 状态的 job，可以通过 kick 重回 READY 状态，也可以通过 delete 删除 job。</p><p>为什么设计这个 BURIED 状态呢？<br>一般我们可以用这个状态来做异常捕获，例如执行超时或者异常的 job，我们可以将其置为 BURIED 状态，这样做有几个好处：<br>1. 可以便面这些异常的 job 直接被放回队列重试，影响正常的队列消费(这些失败一次的 job，很有可能再次失败)。如果没有这个 BURIED 状态，如果我们要单独隔离，一般我们会使用一个新的 tube 单独存放这些异常的 job，使用单独的 consumer 消费。这样就不会影响正常的新消息消费。特别是失败率比较高的时候，会占用很多的正常资源。<br>2. 便于人工排查，上面已经讲到，可以将异常的 job 置为 BURIED 状态，这样人工排查时重点关注这个状态就可以了。</p><h1 id="beanstalkd- 特性"><a href="#beanstalkd- 特性" class="headerlink" title="beanstalkd 特性"></a>beanstalkd 特性 </h1><h2 id="持久化"><a href="# 持久化" class="headerlink" title="持久化"></a> 持久化 </h2><p> 通过 binlog 将 job 及其状态记录到本地文件，当 beanstalkd 重启时，可以通过读取 binlog 来恢复之前的 job 状态。</p><h2 id="分布式"><a href="# 分布式" class="headerlink" title="分布式"></a>分布式 </h2><p> 在 beanstalkd 的文档中，其实是支持分布式的，其设计思想和 Memcached 类似，beanstalkd 各个 server 之间并不知道彼此的存在，是通过 client 实现分布式以及根据 tube 名称去特定的 server 上获取 job。贴一篇专门讨论 beanstalkd 分布式的文章，<a href="https://www.fzb.me/2016-4-1-beanstalkd-in-distributed.html">Beanstalkd 的一种分布式方案</a></p><h2 id="任务延时"><a href="# 任务延时" class="headerlink" title="任务延时"></a>任务延时 </h2><p> 天然支持延时任务，可以在创建 job 时指定延时时间，也可以当 job 被处理完后才能后，消费者使用 release with delay 将 job 再次放入队列延时执行。</p><h2 id="任务优先级"><a href="# 任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>producer 生成的 job 可以给他分配优先级，支持 0 到 2^32 的优先级，值越小，优先级越高，默认优先级为 1024。优先级高的 job 会被 consumer 优先执行。</p><h2 id="超时机制"><a href="# 超时机制" class="headerlink" title="超时机制"></a>超时机制 </h2><p> 为了防止某个 consumer 长时间占用 job 但无法处理完成的情况，beanstalkd 的 reserve 操作支持设置 timeout 时间 (TTR)。如果 consumer 不能在 TTR 内发送 delete、release 或 bury 命令改变 job 状态，那么 beanstalkd 会认为任务处理失败，会将 job 重新置为 READY 状态供其他 consumer 消费。<br> 如果消费者已经预知可能无法在 TTR 内完成该 job，则可以发送 touch 命令，使得 beanstalkd 重新计算 TTR。</p><h2 id="任务预留"><a href="# 任务预留" class="headerlink" title="任务预留"></a>任务预留 </h2><p> 有一个 BURIED 状态可以作为缓冲，具体特点见上文生命周期中关于 BURIED 状态的介绍。</p><h1 id="安装及配置"><a href="# 安装及配置" class="headerlink" title="安装及配置"></a>安装及配置 </h1><p> 以下以 ubuntu 为例，安转 beanstalkd：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install beanstalkd</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/beanstalkd</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line">BEANSTALKD_BINLOG_DIR=/data/beanstalkd/binlog</span><br></pre></td></tr></table></figure><p>可以通过 beanstalkd 命令来运行服务，并且可以添加多种参数。命令的格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">beanstalkd [OPTIONS]</span><br><span class="line"></span><br><span class="line"> -b DIR   wal directory</span><br><span class="line"> -f MS    fsync at most once every MS milliseconds (use -f0 <span class="keyword">for</span> <span class="string">&quot;always fsync&quot;</span>)</span><br><span class="line"> -F       never fsync (default)</span><br><span class="line"> -l ADDR  listen on address (default is 0.0.0.0)</span><br><span class="line"> -p PORT  listen on port (default is 11300)</span><br><span class="line"> -u USER  become user and group</span><br><span class="line"> -z BYTES <span class="built_in">set</span> the maximum job size <span class="keyword">in</span> bytes (default is 65535)</span><br><span class="line"> -s BYTES <span class="built_in">set</span> the size of each wal file (default is 10485760)</span><br><span class="line">            (will be rounded up to a multiple of 512 bytes)</span><br><span class="line"> -c       compact the binlog (default)</span><br><span class="line"> -n       <span class="keyword">do</span> not compact the binlog</span><br><span class="line"> -v       show version information</span><br><span class="line"> -V       increase verbosity</span><br><span class="line"> -h       show this <span class="built_in">help</span></span><br></pre></td></tr></table></figure><br>如下我们启动一个 beanstalkd 服务，并开启 binlog：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup beanstalkd -l 0.0.0.0 -p 11300 -b /data/beanstalkd/binlog/ &amp;</span><br></pre></td></tr></table></figure></p><h2 id="beanstalkd 管理工具"><a href="#beanstalkd 管理工具" class="headerlink" title="beanstalkd 管理工具"></a>beanstalkd 管理工具 </h2><p> 官方推荐的一些管理工具：<a href="https://github.com/beanstalkd/beanstalkd/wiki/Tools">Tools</a><br>笔者常用的管理工具：<a href="https://github.com/ptrofimov/beanstalk_console">https://github.com/ptrofimov/beanstalk_console</a><br>如果只是简单的操作和查看 beanstalkd，可以使用 telnet 工具，然后执行 stats，use，put，watch 等：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 127.0.0.1 11300</span><br><span class="line">stats</span><br></pre></td></tr></table></figure></p><h1 id="实际应用"><a href="# 实际应用" class="headerlink" title="实际应用"></a>实际应用 </h1><p>beansralkd 有很多语言版本的客户端实现，官方提供了一些客户端列表<a href="https://github.com/beanstalkd/beanstalkd/wiki/Client-Libraries">beanstalkd 客户端列表</a>。<br> 如果现有的这些库不满足需求，也可以自行实现，参考 <a href="https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt">beanstalkd 协议</a>。</p><p>以下以 go 为例，简单演示下 beanstalkd 常用处理操作。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/beanstalkd/<span class="keyword">go</span>-beanstalk</span><br></pre></td></tr></table></figure></p><h2 id="生产者"><a href="# 生产者" class="headerlink" title="生产者"></a>生产者 </h2><p> 向默认的 tube 中投入 job：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id, err := conn.Put([]<span class="keyword">byte</span>(<span class="string">&quot;myjob&quot;</span>), <span class="number">1</span>, <span class="number">0</span>, time.Minute)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;job&quot;</span>, id)</span><br></pre></td></tr></table></figure><br>向指定的 tube 中投入 job：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tube := &amp;beanstalk.Tube&#123;Conn: conn, Name: <span class="string">&quot;mytube&quot;</span>&#125;</span><br><span class="line">id, err := tube.Put([]<span class="keyword">byte</span>(<span class="string">&quot;myjob&quot;</span>), <span class="number">1</span>, <span class="number">0</span>, time.Minute)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;job&quot;</span>, id)</span><br></pre></td></tr></table></figure></p><h2 id="消费者"><a href="# 消费者" class="headerlink" title="消费者"></a>消费者 </h2><p> 消费默认的 tube 中的 job：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id, body, err := conn.Reserve(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;job&quot;</span>, id)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure><br>消费指定的 tube (此处指定多个) 中的 job：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tubeSet := beanstalk.NewTubeSet(conn, <span class="string">&quot;mytube1&quot;</span>, <span class="string">&quot;mytube2&quot;</span>)</span><br><span class="line">id, body, err := tubeSet.Reserve(<span class="number">10</span> * time.Hour)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;job&quot;</span>, id)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure></p><h2 id="beanstalkd- 使用小 -tips"><a href="#beanstalkd- 使用小 -tips" class="headerlink" title="beanstalkd 使用小 tips"></a>beanstalkd 使用小 tips</h2><ul><li>可以通过指定 tube ，在 put 的时候将 job 放入指定的 tube 中，否则会放入 default 的 tube 中。</li><li>beanstalkd 支持持久化，在启动时使用 <code>-b</code>参数来开启 <code>binlog</code>，通过<code>binog</code> 可以将 job 及其状态记录到文件里。当重新使用 <code>-b</code> 参数重启 beanstalkd，将读取 <code>binlog</code> 来恢复之前的 job 及状态。</li></ul><h1 id="参考资料"><a href="# 参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://beanstalkd.github.io/">Beanstalkd 官网</a></li><li><a href="https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.zh-CN.md">Beanstalkd 中文协议</a></li><li><a href="https://zhangquan.me/2021/06/29/beanstalkd-xue-xi-yan-jiu/#toc-heading-19">Beanstalkd 学习研究</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;beanstalkd 是一个简单快速的分布式工作队列系统，协议基于 ASCII 编码运行在 TCP 上。其最初设计的目的是通过后台异步执行耗时任务的方式降低高容量 Web 应用的页面延时。其具有简单、轻量、易用等特点，也支持对任务优先级、延时/超时重发等控制，同时还有众多语言版本的客户端支持，这些优点使得它成为各种需要队列系统场景的一种常见选择。&lt;/p&gt;
&lt;h2 id=&quot;beanstalkd-优点&quot;&gt;&lt;a href=&quot;#beanstalkd-优点&quot; class=&quot;headerlink&quot; title=&quot;beanstalkd 优点&quot;&gt;&lt;/a&gt;beanstalkd 优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如他官网的介绍，simple&amp;amp;fast，使用非常简单，适合需要引入消息队列又不想引入 kafka 这类重型的 mq，维护成本低；同时，它的性能非常高，大部分场景下都可以 cover 住。&lt;/li&gt;
&lt;li&gt;支持持久化&lt;/li&gt;
&lt;li&gt;支持消息优先级，topic，延时消息，消息重试等&lt;/li&gt;
&lt;li&gt;主流语言客户端都支持，还可以根据 beanstalkd 协议自行实现。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="消息队列" scheme="http://www.immaxfang.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Linux" scheme="http://www.immaxfang.com/tags/Linux/"/>
    
      <category term="beanstalkd" scheme="http://www.immaxfang.com/tags/beanstalkd/"/>
    
      <category term="MQ" scheme="http://www.immaxfang.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>nginx 信号管理</title>
    <link href="http://www.immaxfang.com/nginx-signal-manage/"/>
    <id>http://www.immaxfang.com/nginx-signal-manage/</id>
    <published>2022-06-29T13:17:17.000Z</published>
    <updated>2023-01-24T05:58:10.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h1><p> 本文笔者主要介绍 nginx 信号管理方面的知识及实践操作，内容包括 nginx 信号管理体系，nginx 信号管理的常见操作，通过具体案例来分析，如 nginx 的 reload，热升级以及日志切割。</p><h1 id="nginx- 命令行管理"><a href="#nginx- 命令行管理" class="headerlink" title="nginx 命令行管理"></a>nginx 命令行管理</h1><p>nginx 的管理可以通过两种方式实现。一种是通过命令行，下面是 nginx 常用的操作命令，</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># nginx -h</span></span><br><span class="line">nginx version: nginx/1.10.3 (Ubuntu)</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span></span><br><span class="line">  -v            : show version and <span class="built_in">exit</span></span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -T            : <span class="built_in">test</span> configuration, dump it and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /usr/share/nginx/)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure><p>另一种管理方式就是我们要介绍的 <code> 信号</code>。</p><h1 id="nginx- 信号管理"><a href="#nginx- 信号管理" class="headerlink" title="nginx 信号管理"></a>nginx 信号管理</h1><p>nginx 的信号管理命令为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> - 参数 nginx 进程号</span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line"><span class="built_in">kill</span> -HUP 54321</span><br><span class="line"><span class="built_in">kill</span> -HUP $(cat /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid)</span><br></pre></td></tr></table></figure><br>nginx 可用的信号如下，具体可以参考官网 <a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/commandline/">nginx.com</a> 。</p><ul><li>master process 可以接收的信号</li></ul><table><thead><tr><th>TERM, INT</th><th>Quick shutdown（优雅关闭进程，等请求结束后再关闭）</th></tr></thead><tbody><tr><td>QUIT</td><td>Graceful shutdown（强制关闭进程）</td></tr><tr><td>KILL</td><td>Halts a stubborn process</td></tr><tr><td>HUP</td><td>Configuration reload, Start the new worker processes with a new configuration, Gracefully shutdown the old worker processes（改变配置后，平滑重新载入配置文件）</td></tr><tr><td>USR1</td><td>Reopen the log files（开启新的日志文件，可以在日志切割时使用）</td></tr><tr><td>USR2</td><td>Upgrade Executable on the fly（平滑升级）</td></tr><tr><td>WINCH</td><td>Gracefully shutdown the worker processes（优雅关闭旧的进程）</td></tr></tbody></table><ul><li>worker process 可以接收的信号</li></ul><table><thead><tr><th>TERM, INT</th><th>Quick shutdown</th></tr></thead><tbody><tr><td>QUIT</td><td>Graceful shutdown</td></tr><tr><td>USR1</td><td>Reopen the log files</td></tr></tbody></table><p>信号与命令行参数的映射关系如下：</p><table><thead><tr><th>参数</th><th>对应信号</th></tr></thead><tbody><tr><td>reload</td><td>HUP</td></tr><tr><td>reopen</td><td>USR1</td></tr><tr><td>stop</td><td>TERM</td></tr><tr><td>quit</td><td>QUIT</td></tr></tbody></table><p>下面来分析下几个常见操作的流程。</p><h1 id="nginx-reload- 优雅重新加载配置"><a href="#nginx-reload- 优雅重新加载配置" class="headerlink" title="nginx reload(优雅重新加载配置)"></a>nginx reload(优雅重新加载配置)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令行</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment"># 使用信号</span></span><br><span class="line"><span class="built_in">kill</span> -HUP nginx 进程号</span><br></pre></td></tr></table></figure><p>当我们发送如上信号时，nginx 就会进行重新加载配置操作，具体的内部执行流程如下。</p><h2 id="nginx-reload- 流程"><a href="#nginx-reload- 流程" class="headerlink" title="nginx reload 流程"></a>nginx reload 流程</h2><ul><li>向 master 进程发送 HUP 信号（reload 命令）</li><li>master 进程校验配置文件语法是否正确</li><li>master 进程打开新的监听端口</li><li>master 进程用新配置启动新的 worker 子进程</li><li>master 进程向老的 worker 子进程发送 QUIT 信号</li><li><p>老的 worker 子进程关闭监听句柄，处理完当前连接后结束进程</p><h2 id="nginx-reload- 实践"><a href="#nginx-reload- 实践" class="headerlink" title="nginx reload 实践"></a>nginx reload 实践</h2><p>reload 前，nginx 进程号如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">root      7491  0.0  0.0  14228   948 pts/0    S+   00:29   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 124264  3004 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data 13254  0.0  0.0 125436  8544 ?        S    Jun12   3:35 nginx: worker process</span><br><span class="line">www-data 13255  0.0  0.0 125428  8380 ?        S    Jun12   3:25 nginx: worker process</span><br><span class="line">www-data 13256  0.0  0.0 125356  8436 ?        S    Jun12   3:39 nginx: worker process</span><br><span class="line">www-data 13257  0.0  0.0 125428  8456 ?        S    Jun12   3:27 nginx: worker process</span><br><span class="line">www-data 13258  0.0  0.0 125428  8468 ?        S    Jun12   3:19 nginx: worker process</span><br><span class="line">www-data 13260  0.0  0.0 125348  8380 ?        S    Jun12   3:17 nginx: worker process</span><br><span class="line">www-data 13261  0.0  0.0 125468  8504 ?        S    Jun12   3:27 nginx: worker process</span><br><span class="line">www-data 13263  0.0  0.0 124844  7928 ?        S    Jun12   3:20 nginx: worker process</span><br></pre></td></tr></table></figure><p>修改配置执行 reload 之后，nginx 进程号发生变化，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># /etc/init.d/nginx reload</span></span><br><span class="line">[ok] Reloading nginx configuration (via systemctl): nginx.service.</span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># </span></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">www-data  7701  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7702  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7704  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7705  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7706  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7707  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7709  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7710  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">root      7737  0.0  0.0  14228   860 pts/0    S+   00:30   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 125828  8540 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br></pre></td></tr></table></figure><h1 id="nginx- 热升级"><a href="#nginx- 热升级" class="headerlink" title="nginx 热升级"></a>nginx 热升级</h1><h2 id="nginx- 热升级流程"><a href="#nginx- 热升级流程" class="headerlink" title="nginx 热升级流程"></a>nginx 热升级流程</h2></li><li><p>将旧的 nginx 二进制文件换成新的 nginx 二进制文件（注意备份）</p></li><li>向 master 进程发送 USR2 信号</li><li>master 进程修改 pid 文件名，加后缀 .oldbin</li><li>master 进程用新 nginx 二进制文件启动新的 master 进程</li><li>向老 master 进程发送 QUIT 信号，关闭老 master 进程</li><li>回滚：向老 master 进程发送 HUP，向新 master 进程发送 QUIT<h2 id="nginx- 热升级实践"><a href="#nginx- 热升级实践" class="headerlink" title="nginx 热升级实践"></a>nginx 热升级实践 </h2> 先将原来的 nginx 二进制文件备份一下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ls -alh /usr/sbin/nginx</span></span><br><span class="line">-rwxr-xr-x 1 root root 1.2M Jan 11  2020 /usr/sbin/nginx</span><br><span class="line"></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># cp /usr/sbin/nginx /usr/sbin/nginx.bak</span></span><br><span class="line"></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># ls -alh /usr/sbin/nginx*</span></span><br><span class="line">-rwxr-xr-x 1 root root 1.2M Jan 11  2020 /usr/sbin/nginx</span><br><span class="line">-rwxr-xr-x 1 root root 1.2M Jun 29 00:32 /usr/sbin/nginx.bak</span><br></pre></td></tr></table></figure>将原来的 nginx 二进制文件替换成新的二进制文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># cp /tmp/nginx.new /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure>向 master 进程发送 USR2 信号<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">www-data  7701  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7702  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7704  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7705  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7706  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7707  0.0  0.0 125828  5896 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7709  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7710  0.0  0.0 125828  5900 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">root      8332  0.0  0.0  14228   916 pts/0    S+   00:33   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 125828  8540 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line"></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># kill -USR2 13253</span></span><br></pre></td></tr></table></figure>此时再看 nginx 进程列表，会发现 nginx 进程数量多了一倍。新的 master 进程是基于新的 nginx 二进制文件运行的，其下也创建了新的 worker 进程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">www-data  7701  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7702  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7704  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7705  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7706  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7707  0.0  0.0 125828  5896 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7709  0.0  0.0 125828  4904 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">www-data  7710  0.0  0.0 125828  5900 ?        S    00:30   0:00 nginx: worker process</span><br><span class="line">root     13253  0.0  0.0 125828  8540 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">www-data  8884  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8885  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8886  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8888  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8889  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8890  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8892  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8893  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">root      8921  0.0  0.0  14228   900 pts/0    S+   00:36   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 125828  8544 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br></pre></td></tr></table></figure>接下来，向老 master 进程发送 QUIT 信号，关闭老 master。随后，我们会发现老 master 和 worker 进程已经关闭，只剩余新的 master 和 worker 进程。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># kill -QUIT 13253</span></span><br><span class="line"></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">www-data  8884  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8885  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8886  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8888  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8889  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8890  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8892  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8893  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">root      8921  0.0  0.0  14228   900 pts/0    S+   00:36   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 125828  8544 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br></pre></td></tr></table></figure>至此，我们就完成了 nginx 热升级过程。<h1 id="nginx- 日志切割"><a href="#nginx- 日志切割" class="headerlink" title="nginx 日志切割"></a>nginx 日志切割</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用命令行</span></span><br><span class="line">nginx -s reopen</span><br><span class="line"><span class="comment"># 使用信号</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 nginx 进程号</span><br></pre></td></tr></table></figure><h2 id="nginx- 日志切割实践"><a href="#nginx- 日志切割实践" class="headerlink" title="nginx 日志切割实践"></a>nginx 日志切割实践 </h2> 初始的日志文件如下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ls -alh /var/log/nginx/access.log</span></span><br><span class="line">-rw-r----- 1 www-data adm 8.1K Jun 28 11:46 /var/<span class="built_in">log</span>/nginx/access.log</span><br></pre></td></tr></table></figure>接着我们讲 access 日志重命名<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># mv /var/log/nginx/access.log /var/log/nginx/access.log.1</span></span><br><span class="line"></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># ls -alh /var/log/nginx/* |grep &#x27;access.log&#x27;</span></span><br><span class="line">-rw-r----- 1 www-data adm  8.1K Jun 28 11:46 /var/<span class="built_in">log</span>/nginx/access.log.1</span><br></pre></td></tr></table></figure>使用日志 reopen，即发送 USR1 信号<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ps aux|grep nginx</span></span><br><span class="line">www-data  8884  0.0  0.0 125828  5900 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8885  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8886  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8888  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8889  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8890  0.1  0.0 125828  5900 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8892  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">www-data  8893  0.0  0.0 125828  4904 ?        S    00:36   0:00 nginx: worker process</span><br><span class="line">root      9873  0.0  0.0  14228  1016 pts/0    S+   00:41   0:00 grep --color=auto nginx</span><br><span class="line">root     13253  0.0  0.0 125828  8544 ?        Ss   Jun12   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># </span></span><br><span class="line">root@sh192-168-1-71:~<span class="comment"># kill -USR1 13253</span></span><br></pre></td></tr></table></figure>此时会发现有新的 access.log 文件生成<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@sh192-168-1-71:~<span class="comment"># ls -alh /var/log/nginx/* |grep &#x27;access.log&#x27;</span></span><br><span class="line">-rw-r--r-- 1 www-data root    0 Jun 29 00:41 /var/<span class="built_in">log</span>/nginx/access.log</span><br><span class="line">-rw-r----- 1 www-data adm  8.1K Jun 28 11:46 /var/<span class="built_in">log</span>/nginx/access.log.1</span><br></pre></td></tr></table></figure></li></ul><p>至此，我们已经了解了 nginx 常见的信号，以及这些信号的实际作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文笔者主要介绍 nginx 信号管理方面的知识及实践操作，内容包括 nginx 信号管理体系，nginx 信号管理的常见操作，通过具体案例来分析，如 nginx 的 reload，热升级以及日志切割。&lt;/p&gt;
&lt;h1 id=&quot;nginx-命令行管理&quot;&gt;&lt;a href=&quot;#nginx-命令行管理&quot; class=&quot;headerlink&quot; title=&quot;nginx 命令行管理&quot;&gt;&lt;/a&gt;nginx 命令行管理&lt;/h1&gt;&lt;p&gt;nginx 的管理可以通过两种方式实现。一种是通过命令行，下面是 nginx 常用的操作命令，&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.immaxfang.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.immaxfang.com/tags/Linux/"/>
    
      <category term="nginx" scheme="http://www.immaxfang.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 使用 postfix 和 AWS-SES 发送邮件</title>
    <link href="http://www.immaxfang.com/postfix-aws-ses/"/>
    <id>http://www.immaxfang.com/postfix-aws-ses/</id>
    <published>2022-06-10T17:27:01.000Z</published>
    <updated>2023-01-24T05:57:31.802Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，邮件发送是个比较常见的场景。因此出现了很多相关的软件和服务，各大云厂商也推出自己的邮件服务。今天笔者就像大家介绍一种常见的组合，AWS 的邮件服务 SES 与邮件服务器 postfix 的配置和使用方法。</p><h1 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述</h1><ul><li>什么是 AWS-SES</li></ul><p>Amazon Simple Email Service (SES) 是一种经济高效、灵活且可扩展的电子邮件服务，使开发人员能够从任何应用程序中发送电子邮件。 您可以快速配置 Amazon SES 以支持多种电子邮件使用案例，包括交易、营销或群发电子邮件通信。</p><span id="more"></span><ul><li>什么是 postfix</li></ul><p>Postfix 是一种电子邮件服务器，它是由任职于 IBM 华生研究中心（T.J. Watson Research Center）的荷兰籍研究员 Wietse Venema 为了改良 sendmail 邮件服务器而产生的。<br>它是为了改良 sendmail 产生的，同时它兼容 sendmail，是比较常用的一种邮件服务器。</p><h1 id="开通 Amazon-Simple-Email-Service-SES- 服务"><a href="# 开通 Amazon-Simple-Email-Service-SES- 服务" class="headerlink" title="开通 Amazon Simple Email Service (SES)服务"></a>开通 Amazon Simple Email Service (SES)服务</h1><ul><li>创建一个 identity</li></ul><p><img src="https://cdn.immaxfang.com/images/post/2022/post-start-ses-1.png" alt="post-start-ses-1.png"></p><p>此处我们为了演示方便，使用 <code>Email address</code> 方式来验证。按下图填入后续要发送邮件的邮箱，随后 AWS 会给对应邮箱发一个确认验证的邮件，点击一下邮件连接即可表示确认授权。</p><p><img src="https://cdn.immaxfang.com/images/post/2022/post-start-ses-2.png" alt="post-start-ses-2.png"></p><ul><li>创建凭证</li></ul><p>选择 Account dashboard，此处的 SMTP endpoint 就是我们的邮件服务器地址，后面配置邮件服务器的时候需要使用。</p><p><img src="https://cdn.immaxfang.com/images/post/2022/post-start-ses-3.png" alt="post-start-ses-3.png"></p><p>点击创建凭证，创建好后，新页面会有下载按钮，一定要及时下载凭证文件。<br>凭证文件里有 Smtp Username 和 Smtp Password，后面配置 postfix 邮件服务器的时候需要用到。</p><p><img src="https://cdn.immaxfang.com/images/post/2022/post-start-ses-4.png" alt="post-start-ses-4.png"></p><ul><li>测试邮件发送</li></ul><p>使用 AWS 自带的功能发送一下测试邮件，查看是否成功。</p><p><img src="https://cdn.immaxfang.com/images/post/2022/post-start-ses-5.png" alt="post-start-ses-5.png"></p><ul><li>其他说明</li></ul><p>SES 的验证方式支持单个邮箱验证和 domain 验证。本文中笔者为了演示简单，采用了单个邮箱验证，如果实际使用中，邮件发送者就是固定的几个邮箱，采用该方法就比较简单。若是邮件发送者比较多，不固定，每个邮箱验证一次不太现实，就可以采用 domain 验证的方式，由域名管理员来配合验证即可，具体的使用 dimain 方式验证的方法，可以参考 aws 官网文档，添加对应的 dns 记录即可。</p><p>至此， SES 服务已经初步开通完毕，下面我们来看下 postfix 的相关配置。</p><h1 id="EC2- 安装 -postfix- 并配置 -SES- 发送邮件"><a href="#EC2- 安装 -postfix- 并配置 -SES- 发送邮件" class="headerlink" title="EC2 安装 postfix 并配置 SES 发送邮件"></a>EC2 安装 postfix 并配置 SES 发送邮件 </h1><p> 笔者的环境是 ubuntu 20.04，其他版本的 ubuntu 方法基本类似。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; cat /etc/lsb-release</span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=20.04</span><br><span class="line">DISTRIB_CODENAME=focal</span><br><span class="line">DISTRIB_DESCRIPTION=<span class="string">&quot;Ubuntu 20.04.3 LTS&quot;</span></span><br></pre></td></tr></table></figure></p><ul><li>安装 postfix 邮件服务</li></ul><p>使用如下命令安装，安装过程中间直接选择默认的配置一路确认即可，后面我们单独修改配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mailutils -y</span><br></pre></td></tr></table></figure><br>安装完成之后，在 AWS 的 EC2 上是无法直接使用 mail 命令发邮件的，需要配置邮件服务器。<br>此处我们以 AWS 的 SES 服务为例，配合 postfix 进行邮件发送。</p><ul><li><p>修改 postfix 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo postconf -e <span class="string">&quot;relayhost = [email-smtp.us-west-2.amazonaws.com]:587&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_sasl_auth_enable = yes&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_sasl_security_options = noanonymous&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_use_tls = yes&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_tls_security_level = encrypt&quot;</span> \</span><br><span class="line"><span class="string">&quot;smtp_tls_note_starttls_offer = yes&quot;</span></span><br><span class="line"></span><br><span class="line">sudo postconf -e <span class="string">&quot;smtp_tls_CAfile = /etc/ssl/certs/ca-certificates.crt&quot;</span></span><br></pre></td></tr></table></figure><p>通过上述命令修改 postfix 的配置，其实修改的就是 <code>/etc/postfix/main.cf</code> 文件，也可以手动使用 vim 等修改，为了保持格式，直接使用自带的 postconf 命令修改即可。<br>注意：上述命令中的 <code>email-smtp.us-west-2.amazonaws.com</code>根据实际情况换成你自己开通的 SES 服务的地址，上文 SES 开通部分有介绍过。</p></li><li><p>填写账号文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/postfix/sasl_passwd</span><br><span class="line"><span class="comment"># 输入如下内容</span></span><br><span class="line">[email-smtp.us-west-2.amazonaws.com]:587 SMTPUSERNAME:SMTPPASSWORD</span><br></pre></td></tr></table></figure><blockquote><p>email-smtp.us-west-2.amazonaws.com：换成你自己的 SES 服务地址<br>SMTPUSERNAME：SMTP 用户名，上文 SES 开通部分有介绍过<br>SMTPPASSWORD：SMTP 密码，同上</p></blockquote></li><li><p>编码账号文件和修改权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo postmap <span class="built_in">hash</span>:/etc/postfix/sasl_passwd</span><br><span class="line"></span><br><span class="line">sudo chown root:root /etc/postfix/sasl_passwd</span><br><span class="line">sudo chown root:root /etc/postfix/sasl_passwd.db</span><br><span class="line">sudo chmod 0600 /etc/postfix/sasl_passwd</span><br><span class="line">sudo chmod 0600 /etc/postfix/sasl_passwd.db</span><br></pre></td></tr></table></figure></li><li><p>重启 postfix 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload postfix</span><br></pre></td></tr></table></figure></li><li><p>测试邮件发送并查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span> | mail -s <span class="string">&quot;test message&quot;</span> -a <span class="string">&quot;From: sender@example.com&quot;</span> receiver@example.com</span><br><span class="line"></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/mail.log</span><br></pre></td></tr></table></figure><p>注意，此处的发送者和收件者邮件需要在 AWS 上进行验证，否则发送邮件会失败。验证方式见前面的 AWS 开通 SES 服务部分。</p><blockquote><p>如果 SES 是在 sandbox 环境中，则发送者 <a href="mailto:`sender@example.com">`sender@example.com</a><code>和 收件人</code><a href="mailto:receiver@example.com">receiver@example.com</a>` 都需要在 AWS 上进行验证。如果是在 production 环境中，则只需要发送者邮件验证通过即可。</p></blockquote></li></ul><p><img src="https://cdn.immaxfang.com/images/post/2022/post-postfix-aws-ses.png" alt="post-postfix-aws-ses"></p><ul><li>其他说明</li></ul><p>若按照如上配置方式，邮件还是发送失败，可以查看机器上的日志，如<code>/var/log/mail.log</code>。还可以检查安全组，看是否是邮件相关端口未开放。</p><p>参考文档：<a href="https://docs.aws.amazon.com/ses/latest/dg/postfix.html">https://docs.aws.amazon.com/ses/latest/dg/postfix.html</a></p><hr><p>更多技术文章，请关注我的个人博客 <a href="https://www.immaxfang.com/">www.immaxfang.com</a> 和小公众号 <code>Max 的学习札记</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常开发中，邮件发送是个比较常见的场景。因此出现了很多相关的软件和服务，各大云厂商也推出自己的邮件服务。今天笔者就像大家介绍一种常见的组合，AWS的邮件服务 SES 与邮件服务器 postfix 的配置和使用方法。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是 AWS-SES&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amazon Simple Email Service (SES) 是一种经济高效、灵活且可扩展的电子邮件服务，使开发人员能够从任何应用程序中发送电子邮件。 您可以快速配置Amazon SES 以支持多种电子邮件使用案例，包括交易、营销或群发电子邮件通信。&lt;/p&gt;
    
    </summary>
    
      <category term="AWS" scheme="http://www.immaxfang.com/categories/AWS/"/>
    
    
      <category term="AWS" scheme="http://www.immaxfang.com/tags/AWS/"/>
    
      <category term="ubuntu" scheme="http://www.immaxfang.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>mydumper-myloader</title>
    <link href="http://www.immaxfang.com/mydumper-myloader/"/>
    <id>http://www.immaxfang.com/mydumper-myloader/</id>
    <published>2022-04-24T17:58:53.000Z</published>
    <updated>2023-01-24T05:58:23.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="# 简介" class="headerlink" title="简介"></a>简介</h1><p>mydumper 是一款开源的 MySQL 逻辑备份工具，主要由 C 语言编写。与 MySQL 自带的 mysqldump 类似，但是 mydumper 更快更高效。<br>mydumper 的一些优点特性：</p><ul><li>轻量级 C 语言开发</li><li>支持多线程备份数据，备份后按表生成多个备份文件</li><li>支持事务性和非事务性表一致性备份</li><li>支持将导出的文件压缩，节约空间</li><li>支持多线程恢复</li><li>支持已守护进程模式工作，定时快照和连续二进制日志</li><li>支持按指定大小将备份文件切割</li><li>数据与建表语句分离</li></ul><span id="more"></span><h1 id="下载安装"><a href="# 下载安装" class="headerlink" title="下载安装"></a>下载安装 </h1><p> 安装方式非常多，以下介绍几种常见的方式。</p><ul><li><p>Ubuntu 中自带了 myloader</p><blockquote><p>sudo apt-get install mydumper</p></blockquote></li><li><p>使用 deb 包安装，以 Ubuntu 为例</p><blockquote><p>apt-get install libatomic1<br>wget <a href="https://github.com/mydumper/mydumper/releases/download/v0.11.5/mydumper_0.11.5-1.$">https://github.com/mydumper/mydumper/releases/download/v0.11.5/mydumper_0.11.5-1.$</a>(lsb_release -cs)_amd64.deb         dpkg -i mydumper_0.11.5-1.$(lsb_release -cs)_amd64.deb</p></blockquote></li><li><p>编译安装</p></li><li>docker 安装</li></ul><p>根据实际平台情况，可选择不同的安装方式，官方也提供了一些常见的安装文档，<a href="https://github.com/mydumper/mydumper">https://github.com/mydumper/mydumper</a></p><h1 id="参数说明"><a href="# 参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><h2 id="mydumper- 参数说明"><a href="#mydumper- 参数说明" class="headerlink" title="mydumper 参数说明"></a>mydumper 参数说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-B, --database              要备份的数据库，不指定则备份所有库，一般建议备份的时候一个库一条命令</span><br><span class="line">-T, --tables-list           需要备份的表，名字用逗号隔开</span><br><span class="line">-o, --outputdir             备份文件输出的目录</span><br><span class="line">-s, --statement-size        生成的 insert 语句的字节数，默认 1000000</span><br><span class="line">-r, --rows                  将表按行分块时，指定的块行数，指定这个选项会关闭 --chunk-filesize</span><br><span class="line">-F, --chunk-filesize        将表按大小分块时，指定的块大小，单位是 MB</span><br><span class="line">-c, --compress              压缩输出文件</span><br><span class="line">-e, --build-empty-files     如果表数据是空，还是产生一个空文件（默认无数据则只有表结构文件）</span><br><span class="line">-x, --regex                 是同正则表达式匹配 &#x27;db.table&#x27;</span><br><span class="line">-i, --ignore-engines        忽略的存储引擎，用逗号分割</span><br><span class="line">-m, --no-schemas            不备份表结构</span><br><span class="line">-d, --no-data               不备份表数据</span><br><span class="line">-G, --triggers              备份触发器</span><br><span class="line">-E, --events                备份事件</span><br><span class="line">-R, --routines              备份存储过程和函数</span><br><span class="line">-W, --no-views              不备份视图</span><br><span class="line">--where                     只导出符合条件的数据</span><br><span class="line">-k, --no-locks              不使用临时共享只读锁，使用这个选项会造成数据不一致</span><br><span class="line">--less-locking              减少对 InnoDB 表的锁施加时间（这种模式的机制下文详解）</span><br><span class="line">-l, --long-query-guard      设定阻塞备份的长查询超时时间，单位是秒，默认是 60 秒（超时后默认 mydumper 将会退出）</span><br><span class="line">--kill-long-queries         杀掉长查询 (不退出)</span><br><span class="line">-b, --binlogs               导出 binlog</span><br><span class="line">-D, --daemon                启用守护进程模式，守护进程模式以某个间隔不间断对数据库进行备份</span><br><span class="line">-I, --snapshot-interval     dump 快照间隔时间，默认 60s，需要在 daemon 模式下</span><br><span class="line">-L, --logfile               使用的日志文件名(mydumper 所产生的日志), 默认使用标准输出</span><br><span class="line">--tz-utc                    跨时区时使用的选项。允许备份 timestamp, 这样会导致不同时区的备份还原出问题，默认关闭。</span><br><span class="line">--skip-tz-utc               同上，默认值。</span><br><span class="line">--use-savepoints            使用 savepoints 来减少采集 metadata 所造成的锁时间，需要 SUPER 权限</span><br><span class="line">--success-on-1146           Not increment error count and Warning instead of Critical in case of table doesn&#x27;t exist</span><br><span class="line">-h, --host                  连接的主机名</span><br><span class="line">-u, --user                  备份所使用的用户</span><br><span class="line">-p, --password              密码</span><br><span class="line">-P, --port                  端口</span><br><span class="line">-S, --socket                使用 socket 通信时的 socket 文件</span><br><span class="line">-t, --threads               开启的备份线程数，默认是 4</span><br><span class="line">-C, --compress-protocol     压缩与 mysql 通信的数据</span><br><span class="line">-V, --version               显示版本号</span><br><span class="line">-v, --verbose               输出信息模式, 0 = silent, 1 = errors, 2 = warnings, 3 = info, 默认为 2</span><br></pre></td></tr></table></figure><h2 id="myloader- 参数说明"><a href="#myloader- 参数说明" class="headerlink" title="myloader 参数说明"></a>myloader 参数说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-d, --directory                   备份文件的文件夹</span><br><span class="line">-q, --queries-per-transaction     每次事务执行的查询数量，默认是 1000</span><br><span class="line">-o, --overwrite-tables            如果要恢复的表存在，则先 drop 掉该表，使用该参数，需要备份时候要备份表结构</span><br><span class="line">-B, --database                    还原到的数据库（目标库）</span><br><span class="line">-s, --source-db                   被还原的数据库（源数据库），-s db1 -B db2，表示源库中的 db1 数据库，导入到 db2 数据库中。</span><br><span class="line">-e, --enable-binlog               启用还原数据的二进制日志，具体见下面关于 -e 的提示说明</span><br><span class="line">-h, --host                        主机</span><br><span class="line">-u, --user                        还原的用户</span><br><span class="line">-p, --password                    密码</span><br><span class="line">-P, --port                        端口</span><br><span class="line">-S, --socket                      socket 文件</span><br><span class="line">-t, --threads                     还原所使用的线程数，默认是 4</span><br><span class="line">-C, --compress-protocol           压缩协议</span><br><span class="line">-V, --version                     显示版本</span><br><span class="line">-v, --verbose                     输出模式, 0 = silent, 1 = errors, 2 = warnings, 3 = info, 默认为 2</span><br></pre></td></tr></table></figure><h1 id="常用案例"><a href="# 常用案例" class="headerlink" title="常用案例"></a>常用案例</h1><h2 id="mydumper- 导出示例"><a href="#mydumper- 导出示例" class="headerlink" title="mydumper 导出示例"></a>mydumper 导出示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 个人实际中最常用的备份语句</span></span><br><span class="line">mydumper -B test -o /home/mydumper/data/test -e -G -R -E -D -u root -p 123456 -h 192.168.0.191 -P 3306 -v 3 --long-query-guard 288000 --skip-tz-utc --no-locks --logfile /home/mydumper/log/test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份全部数据库</span> </span><br><span class="line">mydumper -u root -p 123456 -o /home/mydumper/data/all/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份全部数据库，排除系统库，</span></span><br><span class="line">mydumper -u root -p 123456 --regex &#x27;^(?!(mysql|sys|performance_schema|information_schema))&#x27; -o /home/mydumper/data/all/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份全部数据库，包含触发器、事件、存储过程及函数</span></span><br><span class="line">mydumper -u root -p 123456 -G -R -E -o /home/mydumper/data/all/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份指定库</span></span><br><span class="line">mydumper -u root -p 123456 -G -R -E -B db1 -o /home/mydumper/data/db1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份指定表</span></span><br><span class="line">mydumper -u root -p 123456 -B db1 -T tb1,tb2 -o /home/mydumper/data/db1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只备份表结构</span></span><br><span class="line">mydumper -u root -p 123456 -B db1 -d -o /home/mydumper/data/db1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只备份表数据</span></span><br><span class="line">mydumper -u root -p 123456 -B db1 -m -o /home/mydumper/data/db1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="myloader- 导入案例"><a href="#myloader- 导入案例" class="headerlink" title="myloader 导入案例"></a>myloader 导入案例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 个人实际中最常用的导入语句</span></span><br><span class="line">myloader -h 192.168.0.192 -P 33306 -u root -p 123456 -t 1 -v 3 -d /home/mydumper/data/test/0/ -B test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从备份中恢复指定库</span></span><br><span class="line">myloader -u root -p 123456 -s db1 -o -d /home/mydumper/data/all/0/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入时开启 binlog</span></span><br><span class="line">myloader -u root -p 123456 -e -o -d /home/mydumper/data/db1/0/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将源库的 db1 导入到备库的 db1_bak 库中</span></span><br><span class="line">myloader -u root -p 123456 -B db1_bak -s db1 -o -d /home/mydumper/data/db1/0/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入特定的某几张表</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 先将 metadata 文件和需要单独导入的表的结构文件和数据文件导入到单独的文件夹中。此处默认库已建好，否则还需要复制建库相关语句。</span></span></span><br><span class="line">cp /home/mydumper/data/db1/0/metadata /backup/db1/0/</span><br><span class="line">cp /home/mydumper/data/db1/0/d1.t1-schema.sql /backup/db1/0/</span><br><span class="line">cp /home/mydumper/data/db1/0/d1.t1.sql /backup/db1/0/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 从新文件夹中导入数据</span></span></span><br><span class="line">myloader -u root -p 123456 -B db1 -d /backup/db1/0/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 以上就可以单独导入 db1.t1 表</span></span></span><br></pre></td></tr></table></figure><blockquote><p>关于 -e 参数，需要稍微注意下。默认情况下，myloader 是不开启 binlog 的，这样可以提高导入速度。如果导入实例有从库，且需要导入的结果同步到从库上，则需要使用 -e 打开 binlog 记录。</p></blockquote><p>导出之后的目录如下，以数据库 d1 ，其中有表  t1 为例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-d1</span><br><span class="line"> -0</span><br><span class="line">   metadata             记录备份时间点的 Binlog 信息，日志文件名和写入位置</span><br><span class="line">   d1-schema-create.sql 建库语句</span><br><span class="line">   d1-schema-post.sql   存储过程，函数，事件创建语句</span><br><span class="line">   d1.t1-schema.sql     表结构文件</span><br><span class="line">   d1.t1.sql            表数据文件，若使用了分块参数，大表的数据文件会出现多个，以数字分开。</span><br><span class="line"> -1</span><br></pre></td></tr></table></figure></p><blockquote><p>以上为比较常见的导出后的目录结构，根据实际情况不同，可能还有会含有触发器的文件，含有视图的文件等。</p></blockquote><h1 id="常见问题与实践经验"><a href="# 常见问题与实践经验" class="headerlink" title="常见问题与实践经验"></a>常见问题与实践经验</h1><ul><li><p>Error switching to database whilst restoring table</p><p>  使用 myloader 导入时会出现这类报错，可以尝试的解决方法如下：调大 wait_timeout 参数；调大 max_packet_size 参数；使用一个线程导入，  -t 1。</p></li><li><p>(myloader:35671): CRITICAL **: Error restoring test.email_logger from file test.email_logger.sql: Cannot create a JSON value from a string with CHARACTER SET ‘binary’.</p><p> MySQL 的一个 Bug，可以尝试手动修改对应的备份文件，将 </p><blockquote><p>/<em>!40101 SET NAMES binary</em>/;</p></blockquote><p> 修改为：</p><blockquote><p>/<em>!40101 SET NAMES utf8mb4</em>/;</p></blockquote></li><li><p>(myloader:34726): CRITICAL **: Error restoring test.(null) from file test-schema-post.sql: Access denied; you need (at least one of) the SUPER privilege(s) for this operation</p><p> 在导入 AWS RDS 时部分存储过程创建失败，有比较严格的权限限制，需要导入用户有 SUPER 权限，但是 AWS RDS 用户无法授予 SUPER 权限。针对这部分存储过程，可以考虑手动在备份库上创建。</p></li><li><p>大表导出优化</p><p>  使用 <code>-r</code>或 <code>-F</code> 参数，对导出的数据文件进行分片。</p></li><li><p>备份机器配置尽可能高</p><p>  备份前先预估大小，避免机器磁盘不足。尽可能选用配置较高的机器，加快备份速度。</p></li><li><p>非必要数据不备份</p><p>  备份前对于不用备份的数据可以提前进行一次删除，也可在导出数据时添加正则参数等过滤部分表</p></li><li><p>备份尽量不跨网络</p><p>  备份数据时尽量在内网中进行，若需要将数据迁移到外网，可以备份完之后，将备份文件拷贝到外网服务器上，尽量减少导出时网络不稳定的干扰。导入时同理。</p></li><li><p>加快导入速度的一些方法</p><p>  选择合适的线程数，根据实际情况和机器配置，选择合适的线程参数，并非线程数越多越快。<br>  导入时关闭 MySQL 的 binlog 写入，待导入完成后再开启。<br>  在内网或较稳定的环境中进行导入。</p></li></ul><h1 id="原理与架构"><a href="# 原理与架构" class="headerlink" title="原理与架构"></a>原理与架构 </h1><h2 id="mydumper- 工作流程"><a href="#mydumper- 工作流程" class="headerlink" title="mydumper 工作流程"></a>mydumper 工作流程</h2><p><img src="https://cdn.immaxfang.com/images/post/2022/post-mydumper.png" alt><br> 主要步骤概括</p><ul><li>主线程 FLUSH TABLES WITH READ LOCK，施加全局只读锁，阻止 DML 语句写入，保证数据的一致性。</li><li>读取当前时间点的二进制日志文件名和日志写入的位置并记录在 metadata 文件中。</li><li>N 个 dump 线程 START TRANSACTION WITH CONSISTENT SNAPSHOT，开启读一致的事务。</li><li>dump non-InnoDB tables， 首先导出非事务引擎的表。</li><li>主线程 UNLOCK TABLES 非事务引擎备份完后，释放全局只读锁。</li><li>dump InnoDB tables，基于事务导出 InnoDB 表。</li><li>事务结束。</li></ul><h2 id="myloader- 工作原理"><a href="#myloader- 工作原理" class="headerlink" title="myloader 工作原理"></a>myloader 工作原理</h2><p><img src="https://cdn.immaxfang.com/images/post/2022/post-myloader.png" alt></p><hr><p>更多技术文章，请关注我的个人博客 <a href="https://www.immaxfang.com/">www.immaxfang.com</a> 和小公众号 <code>Max 的学习札记</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;mydumper 是一款开源的 MySQL 逻辑备份工具，主要由 C 语言编写。与 MySQL 自带的 mysqldump 类似，但是 mydumper 更快更高效。&lt;br&gt;mydumper 的一些优点特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量级C语言开发&lt;/li&gt;
&lt;li&gt;支持多线程备份数据，备份后按表生成多个备份文件&lt;/li&gt;
&lt;li&gt;支持事务性和非事务性表一致性备份&lt;/li&gt;
&lt;li&gt;支持将导出的文件压缩，节约空间&lt;/li&gt;
&lt;li&gt;支持多线程恢复&lt;/li&gt;
&lt;li&gt;支持已守护进程模式工作，定时快照和连续二进制日志&lt;/li&gt;
&lt;li&gt;支持按指定大小将备份文件切割&lt;/li&gt;
&lt;li&gt;数据与建表语句分离&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.immaxfang.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.immaxfang.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>git 使用命令行保留原分支迁移代码仓库</title>
    <link href="http://www.immaxfang.com/git-migrate-project/"/>
    <id>http://www.immaxfang.com/git-migrate-project/</id>
    <published>2022-03-18T17:54:57.000Z</published>
    <updated>2023-01-24T05:59:09.620Z</updated>
    
    <content type="html"><![CDATA[<p> 有些时候我们需要对 git 仓库中的项目进行一些迁移，如从 a 账号迁移到 b 账号下，从 github 平台迁移到内部的 gitlab 平台等。一般平台会自带 migrate 或者 import 的功能，可以很方便的进行仓库的迁移。当然，我们也可以自行进行迁移，当需要迁移的项目比较多时，脚本进行迁移更快捷。</p><p> 下面来看看如何进行手动迁移，同时在迁移后，保留原项目的分支和 tag，以及提交记录等。</p><span id="more"></span><ul><li> 先将待迁移的项目 clone 下来 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --mirror &lt;url_of_old_repo&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;name_of_old_repo&gt;</span><br></pre></td></tr></table></figure><ul><li> 确保新的空仓库已经创建完成，然后即可将项目推送到新的空仓库中。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin &lt;url_of_new_repo&gt;</span><br><span class="line">git push origin --mirror</span><br></pre></td></tr></table></figure><p> 大功告成，可以看到新的仓库中，项目的分支和 tag，以及提交记录等，都会保留。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些时候我们需要对git仓库中的项目进行一些迁移，如从a账号迁移到b账号下，从github平台迁移到内部的gitlab平台等。一般平台会自带 migrate 或者 import 的功能，可以很方便的进行仓库的迁移。当然，我们也可以自行进行迁移，当需要迁移的项目比较多时，脚本进行迁移更快捷。&lt;/p&gt;
&lt;p&gt;下面来看看如何进行手动迁移，同时在迁移后，保留原项目的分支和tag，以及提交记录等。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://www.immaxfang.com/categories/git/"/>
    
    
      <category term="git" scheme="http://www.immaxfang.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>laravel 源码分析 - 队列 Queue</title>
    <link href="http://www.immaxfang.com/source-analysis-laravel-queue/"/>
    <id>http://www.immaxfang.com/source-analysis-laravel-queue/</id>
    <published>2022-01-07T07:28:21.000Z</published>
    <updated>2023-01-24T05:57:43.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>laravel 源码分析具体注释见 <a href="https://github.com/FX-Max/source-analysis-laravel">https://github.com/FX-Max/source-analysis-laravel</a></p></blockquote><h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h1><p> 队列 (Queue) 是 laravel 中比较常用的一个功能，队列的目的是将耗时的任务延时处理，比如发送邮件，从而大幅度缩短 Web 请求和响应的时间。本文我们就来分析下队列创建和执行的源码。</p><blockquote><p>本文笔者基于 laravel 5.8.* 版本</p></blockquote><h1 id="队列任务的创建"><a href="# 队列任务的创建" class="headerlink" title="队列任务的创建"></a>队列任务的创建 </h1><p> 先通过命令创建一个 Job 类，成功之后会创建如下文件 laravel-src/laravel/app/Jobs/DemoJob.php。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; php artisan make:job DemoJob</span><br><span class="line"></span><br><span class="line">&gt; Job created successfully.</span><br></pre></td></tr></table></figure><p>下面我们来分析一下 Job 类的具体生成过程。</p><p>执行 <code>php artisan make:job DemoJob</code> 后，会触发调用如下方法。</p><p>laravel-src/laravel/vendor/laravel/framework/src/Illuminate/Foundation/Providers/ArtisanServiceProvider.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the command.</span></span><br><span class="line"><span class="comment"> * [A] make:job 时触发的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerJobMakeCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">&#x27;command.job.make&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$app</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JobMakeCommand(<span class="variable">$app</span>[<span class="string">&#x27;files&#x27;</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来看下 JobMakeCommand 这个类，这个类里面没有过多的处理逻辑，处理方法在其父类中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobMakeCommand</span> <span class="keyword">extends</span> <span class="title">GeneratorCommand</span></span></span><br></pre></td></tr></table></figure><p>我们直接看父类中的处理方法，GeneratorCommand-&gt;handle()，以下是该方法中的主要方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取类名</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="keyword">$this</span>-&gt;qualifyClass(<span class="keyword">$this</span>-&gt;getNameInput());</span><br><span class="line">    <span class="comment">// 获取文件路径</span></span><br><span class="line">    <span class="variable">$path</span> = <span class="keyword">$this</span>-&gt;getPath(<span class="variable">$name</span>);</span><br><span class="line">    <span class="comment">// 创建目录和文件</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;makeDirectory(<span class="variable">$path</span>);</span><br><span class="line">    <span class="comment">// buildClass() 通过模板获取新类文件的内容</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;files-&gt;put(<span class="variable">$path</span>, <span class="keyword">$this</span>-&gt;buildClass(<span class="variable">$name</span>));</span><br><span class="line">    <span class="comment">// $this-&gt;type 在子类中定义好了，例如 JobMakeCommand 中 type = &#x27;Job&#x27;</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;info(<span class="keyword">$this</span>-&gt;type.<span class="string">&#x27; created successfully.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法就是通过目录和文件，创建对应的类文件，至于新文件的内容，都是基于已经设置好的模板来创建的，具体的内容在 buildClass($name) 方法中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildClass</span>(<span class="params"><span class="variable">$name</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到类文件模板，getStub() 在子类中有实现，具体看 JobMakeCommand </span></span><br><span class="line">    <span class="variable">$stub</span> = <span class="keyword">$this</span>-&gt;files-&gt;get(<span class="keyword">$this</span>-&gt;getStub());</span><br><span class="line">    <span class="comment">// 用实际的 name 来替换模板中的内容，都是关键词替换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;replaceNamespace(<span class="variable">$stub</span>, <span class="variable">$name</span>)-&gt;replaceClass(<span class="variable">$stub</span>, <span class="variable">$name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取模板文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getStub</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;option(<span class="string">&#x27;sync&#x27;</span>)</span><br><span class="line">                    ? <span class="keyword">__DIR__</span>.<span class="string">&#x27;/stubs/job.stub&#x27;</span></span><br><span class="line">                    : <span class="keyword">__DIR__</span>.<span class="string">&#x27;/stubs/job-queued.stub&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>job.stub</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* job 类的生成模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DummyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Bus</span>\<span class="title">Dispatchable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">Queueable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new job instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute the job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>job-queued.stub</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* job 类的生成模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DummyNamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">SerializesModels</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">InteractsWithQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Queue</span>\<span class="title">ShouldQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Bus</span>\<span class="title">Dispatchable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new job instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute the job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看一下前面我们创建的一个 Job 类，DemoJob.php，就是来源于模板 job-queued.stub。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* job 类的生成模板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Jobs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">SerializesModels</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">InteractsWithQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Queue</span>\<span class="title">ShouldQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Bus</span>\<span class="title">Dispatchable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoJob</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new job instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute the job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经大致明白了队列任务类是如何创建的了。下面我们来分析下其是如何生效运行的。</p><h1 id="队列任务的分发"><a href="# 队列任务的分发" class="headerlink" title="队列任务的分发"></a>队列任务的分发 </h1><p> 任务类创建后，我们就可以在需要的地方进行任务的分发，常见的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DemoJob::dispatch(); // 任务分发</span><br><span class="line">DemoJob::dispatchNow(); // 同步调度，队列任务不会排队，并立即在当前进程中进行</span><br></pre></td></tr></table></figure><p>下面先以 dispatch() 为例分析下分发过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trait Dispatchable</span><br><span class="line">&#123;</span><br><span class="line">    public static function dispatch()</span><br><span class="line">    &#123;</span><br><span class="line">        return new PendingDispatch(new static(...func_get_args()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PendingDispatch</span><br><span class="line">&#123;</span><br><span class="line">    protected $job;</span><br><span class="line"></span><br><span class="line">    public function __construct($job)</span><br><span class="line">    &#123;   echo &#x27;[Max] &#x27; . &#x27;PendingDispatch &#x27; . &#x27;__construct&#x27; . PHP_EOL;</span><br><span class="line">        $this-&gt;job = $job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __destruct()</span><br><span class="line">    &#123;   echo &#x27;[Max] &#x27; . &#x27;PendingDispatch &#x27; . &#x27;__destruct&#x27; . PHP_EOL;</span><br><span class="line">        app(Dispatcher::class)-&gt;dispatch($this-&gt;job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是 app(Dispatcher::class)-&gt;dispatch($this-&gt;job) 这部分。</p><p>我们先来分析下前部分 app(Dispatcher::class)，它是在 laravel 框架中自带的 BusServiceProvider 中向 $app 中注入的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BusServiceProvider extends ServiceProvider implements DeferrableProvider</span><br><span class="line">&#123;</span><br><span class="line">    public function register()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;app-&gt;singleton(Dispatcher::class, function ($app) &#123;</span><br><span class="line">            return new Dispatcher($app, function ($connection = null) use ($app) &#123;</span><br><span class="line">                return $app[QueueFactoryContract::class]-&gt;connection($connection);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下 Dispatcher 的构造方法，至此，我们已经知道前半部分 app(Dispatcher::class) 是如何来的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Dispatcher implements QueueingDispatcher</span><br><span class="line">&#123;</span><br><span class="line">    protected $container;</span><br><span class="line">    protected $pipeline;</span><br><span class="line">    protected $queueResolver;</span><br><span class="line"></span><br><span class="line">    public function __construct(Container $container, Closure $queueResolver = null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;container = $container;</span><br><span class="line">        /**</span><br><span class="line">         * Illuminate/Bus/BusServiceProvider.php-&gt;register()中</span><br><span class="line">         * $queueResolver 传入的是一个闭包</span><br><span class="line">         * function ($connection = null) use ($app) &#123;</span><br><span class="line">         *   return $app[QueueFactoryContract::class]-&gt;connection($connection);</span><br><span class="line">         * &#125;</span><br><span class="line">         */</span><br><span class="line">        $this-&gt;queueResolver = $queueResolver;</span><br><span class="line">        $this-&gt;pipeline = new Pipeline($container);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function dispatch($command)</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123;</span><br><span class="line">        // 将 $command 存入队列</span><br><span class="line">            return $this-&gt;dispatchToQueue($command);</span><br><span class="line">        &#125;</span><br><span class="line">        return $this-&gt;dispatchNow($command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BusServiceProvider 中注册了 Dispatcher::class ，然后 app(Dispatcher::class)-&gt;dispatch($this-&gt;job) 调用的即是 Dispatcher-&gt;dispatch()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public function dispatchToQueue($command)</span><br><span class="line">&#123;</span><br><span class="line">    // 获取任务所属的 connection</span><br><span class="line">    $connection = $command-&gt;connection ?? null;</span><br><span class="line">    /*</span><br><span class="line">     * 获取队列实例，根据 config/queue.php 中的配置</span><br><span class="line">     * 此处我们配置 QUEUE_CONNECTION=redis 为例，则获取的是 RedisQueue</span><br><span class="line">     * 至于如何通过 QUEUE_CONNECTION 的配置获取 queue ，此处先跳过，本文后面会具体分析。</span><br><span class="line">     */</span><br><span class="line">    $queue = call_user_func($this-&gt;queueResolver, $connection);</span><br><span class="line"></span><br><span class="line">    if (! $queue instanceof Queue) &#123;</span><br><span class="line">        throw new RuntimeException(&#x27;Queue resolver did not return a Queue implementation.&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 我们创建的 DemoJob 无 queue 方法，则不会调用</span><br><span class="line">    if (method_exists($command, &#x27;queue&#x27;)) &#123;</span><br><span class="line">        return $command-&gt;queue($queue, $command);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将 job 放入队列</span><br><span class="line">    return $this-&gt;pushCommandToQueue($queue, $command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected function pushCommandToQueue($queue, $command)</span><br><span class="line">&#123;</span><br><span class="line">    // 在指定了 queue 或者 delay 时会调用不同的方法，基本大同小异</span><br><span class="line">    if (isset($command-&gt;queue, $command-&gt;delay)) &#123;</span><br><span class="line">        return $queue-&gt;laterOn($command-&gt;queue, $command-&gt;delay, $command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isset($command-&gt;queue)) &#123;</span><br><span class="line">        return $queue-&gt;pushOn($command-&gt;queue, $command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isset($command-&gt;delay)) &#123;</span><br><span class="line">        return $queue-&gt;later($command-&gt;delay, $command);</span><br><span class="line">    &#125;</span><br><span class="line">    // 此处我们先看最简单的无参数时的情况，调用 push()</span><br><span class="line">    return $queue-&gt;push($command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>笔者的配置是 QUEUE_CONNECTION=redis ，估以此来分析，其他类型的原理基本类似。</p></blockquote><p>配置的是 redis 时， $queue 是 RedisQueue 实例，下面我们看下 RedisQueue-&gt;push() 的内容。</p><p>Illuminate/Queue/RedisQueue.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public function push($job, $data = &#x27;&#x27;, $queue = null)</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取队列名称</span><br><span class="line">     * var_dump($this-&gt;getQueue($queue));</span><br><span class="line">     * 创建统一的 payload，转成 json</span><br><span class="line">     * var_dump($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data));</span><br><span class="line">     */</span><br><span class="line">    // 将任务和数据存入队列</span><br><span class="line">    return $this-&gt;pushRaw($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public function pushRaw($payload, $queue = null, array $options = [])</span><br><span class="line">&#123;</span><br><span class="line">    // 写入 redis 中</span><br><span class="line">    $this-&gt;getConnection()-&gt;eval(</span><br><span class="line">        LuaScripts::push(), 2, $this-&gt;getQueue($queue),</span><br><span class="line">        $this-&gt;getQueue($queue).&#x27;:notify&#x27;, $payload</span><br><span class="line">    );</span><br><span class="line">    // 返回 id</span><br><span class="line">    return json_decode($payload, true)[&#x27;id&#x27;] ?? null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们已经分析完了任务是如何被加入到队列中的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;laravel 源码分析具体注释见 &lt;a href=&quot;https://github.com/FX-Max/source-analysis-laravel&quot;&gt;https://github.com/FX-Max/source-analysis-laravel&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;队列 (Queue) 是 laravel 中比较常用的一个功能，队列的目的是将耗时的任务延时处理，比如发送邮件，从而大幅度缩短 Web 请求和响应的时间。本文我们就来分析下队列创建和执行的源码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文笔者基于 laravel 5.8.* 版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;队列任务的创建&quot;&gt;&lt;a href=&quot;#队列任务的创建&quot; class=&quot;headerlink&quot; title=&quot;队列任务的创建&quot;&gt;&lt;/a&gt;队列任务的创建&lt;/h1&gt;&lt;p&gt;先通过命令创建一个 Job 类，成功之后会创建如下文件 laravel-src/laravel/app/Jobs/DemoJob.php。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.immaxfang.com/categories/php/"/>
    
    
      <category term="php" scheme="http://www.immaxfang.com/tags/php/"/>
    
      <category term="laravel" scheme="http://www.immaxfang.com/tags/laravel/"/>
    
      <category term="源码分析" scheme="http://www.immaxfang.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>hexo 升级 5.4.0 出现错误解决方法 -hexo-theme-butterfly</title>
    <link href="http://www.immaxfang.com/hexo-upgrade-2021/"/>
    <id>http://www.immaxfang.com/hexo-upgrade-2021/</id>
    <published>2021-09-26T16:39:59.000Z</published>
    <updated>2023-01-24T05:59:40.450Z</updated>
    
    <content type="html"><![CDATA[<p> 周末升级了下 hexo 到新版本，发现升级后，构建时出现了一些错误，以下是出现的问题，及解决方法。</p><ul><li>WARN  Deprecated config detected: “external_link” with a Boolean value is deprecated. See <a href="https://hexo.io/docs/configuration">https://hexo.io/docs/configuration</a> for more details.</li></ul><span id="more"></span><p> 修改 _config.yml 文件，将如下内容做调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_link: true</span><br></pre></td></tr></table></figure><p> 将上面的内容，修改为如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br></pre></td></tr></table></figure><ul><li>err: TypeError: Cannot read property ‘bind’ of undefined</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err: TypeError: Cannot read property &#x27;bind&#x27; of undefined</span><br><span class="line">...</span><br><span class="line">Script load failed: %s themes/butterfly/scripts/filters/post_lazyload.js</span><br></pre></td></tr></table></figure><p> 一般出现类似错误是由于升级 hexo 后，其余依赖未升级完全，可以考虑删除依赖，重新 install。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line">rm -rf node_modules</span><br><span class="line">rm package-lock.json</span><br><span class="line">npm install</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p> 可以参考 git 主题项目中的 <a href="https://github.com/jerryc127/hexo-theme-butterfly/issues/406">issues-406</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末升级了下 hexo 到新版本，发现升级后，构建时出现了一些错误，以下是出现的问题，及解决方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WARN  Deprecated config detected: “external_link” with a Boolean value is deprecated. See &lt;a href=&quot;https://hexo.io/docs/configuration&quot;&gt;https://hexo.io/docs/configuration&lt;/a&gt; for more details.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.immaxfang.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.immaxfang.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>YAML 语言初识</title>
    <link href="http://www.immaxfang.com/yaml-quick-start/"/>
    <id>http://www.immaxfang.com/yaml-quick-start/</id>
    <published>2021-09-21T16:16:18.000Z</published>
    <updated>2023-01-24T05:58:02.453Z</updated>
    
    <content type="html"><![CDATA[<p> 日常工作中，我们经常会遇到 YAML，例如 docker-compose 配置，ELK 中的 filebeat 配置， K8S 集群配置，ansible 的 playbook 等，也有越来越多的项目使用了 YAML 作为配置文件的选型。那今天，我们就来了解下它到底是何许人也。</p><h1 id="什么是 -YAML"><a href="# 什么是 -YAML" class="headerlink" title="什么是 YAML"></a> 什么是 YAML</h1><p>YAML 官网：<a href="https://yaml.org/">https://yaml.org/</a></p><p>YAML (YAML: YAML Ain’t Markup Language) 是一种类似 XML，JSON 的数据序列化语言，是一种通用的数据串行化格式。它是主要用来写配置文件的语言，比 XML 要简洁和简单，便于人阅读理解，号称 <code> 一种人性化的数据格式语言 </code> 。</p><p> 正如其官网介绍，What It Is: YAML is a human friendly data serialization standard for all programming languages.</p><span id="more"></span><h1 id="YAML- 的基本语法"><a href="#YAML- 的基本语法" class="headerlink" title="YAML 的基本语法"></a>YAML 的基本语法 </h1><p>YAML 配置文件的后缀为 .yml，如 docker-compose.yml。</p><p> 基本语法 </p><ul><li> 大小写敏感 </li><li> 使用缩进表示层级关系 </li><li> 缩进不允许使用 tab，仅允许空格 </li><li> 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 </li><li><code>#</code> 表示注释 </li></ul><p> 最基本的一个文件结构如下，demo.yml<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br></pre></td></tr></table></figure></p><p> 若是要在一个文件中进行多个文档配置，则多个文档之间需要使用“—”(三个横线) 作为分隔符。例如 demo2.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v2</span><br><span class="line">kind: Pod</span><br></pre></td></tr></table></figure><h1 id="YAML- 的几种数据结构"><a href="#YAML- 的几种数据结构" class="headerlink" title="YAML 的几种数据结构"></a>YAML 的几种数据结构 </h1><p>YAML 支持的基础数据结构有三种。</p><ul><li> 对象（Maps）：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li> 数组（Lists）：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li> 纯量（scalars）：单个的、不可再分的值 </li></ul><h2 id="Maps- 对象"><a href="#Maps- 对象" class="headerlink" title="Maps ( 对象)"></a>Maps (对象)</h2><p>Maps 键值对使用冒号结构表示，key: value，冒号后面需要加一个空格。<br> 也可以使用 key:{key1: value1, key2: value2, key3: value3} 来表示（一般不常用）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 </span><br><span class="line">kind: Pod</span><br></pre></td></tr></table></figure><p> 上面的例子中，表示有两个键：<code>apiVersion</code> 和 <code>kind</code> ，它们对应的值分别是 <code>v1</code> 和 <code>Pod</code> 。上面的 YAML 文件转换成 JSON 格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">&quot;kind&quot;: &quot;pod&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 下面来看一些复杂的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: k8s-web-pod</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br></pre></td></tr></table></figure><p> 该配置文件中，<code>metadata</code> 这个 key 对应的 value 就是一个 Maps，并且下一层的 <code>labels</code> 对应的 value 又是一个 Maps，实际使用中，可能会有多层的嵌套。<br> 上面的 YAML 文件转换成 JSON 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">&quot;kind&quot;: &quot;Pod&quot;,</span><br><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">&quot;name&quot;: &quot;k8s-web-pod&quot;,</span><br><span class="line">&quot;labels&quot;: &#123;</span><br><span class="line">&quot;app&quot;: &quot;web&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 前面提到了，在 YAML 文件中，一定不要使用 tab，层级中的缩进没有做具体规定，只要保持一致即可，我们所在的团队中使用两个空格。YAML 解析器根据缩进来处理内容之间的关联性。</p></blockquote><h2 id="Lists- 数组"><a href="#Lists- 数组" class="headerlink" title="Lists ( 数组)"></a>Lists (数组)</h2><p> 一组连线 <code>-</code> 开头的行，构成一个数组。在 YAML 中我们可以这样定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> - Java</span><br><span class="line"> - Python</span><br><span class="line"> - Go</span><br><span class="line"> - PHP</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&quot;Java&quot;,</span><br><span class="line">&quot;Python&quot;,</span><br><span class="line">&quot;Go&quot;,</span><br><span class="line">&quot;PHP&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- </span><br><span class="line"> - Java</span><br><span class="line"> - Python</span><br><span class="line"> - Go</span><br><span class="line"> - PHP</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"> - Java2</span><br><span class="line"> - Python2</span><br><span class="line"> - Go2</span><br><span class="line"> - PHP2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[</span><br><span class="line">&quot;Java&quot;,</span><br><span class="line">&quot;Python&quot;,</span><br><span class="line">&quot;Go&quot;,</span><br><span class="line">&quot;PHP&quot;</span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line">&quot;Java2&quot;,</span><br><span class="line">&quot;Python2&quot;,</span><br><span class="line">&quot;Go2&quot;,</span><br><span class="line">&quot;PHP2&quot;</span><br><span class="line">]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="复合结构"><a href="# 复合结构" class="headerlink" title="复合结构"></a> 复合结构 </h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> language:</span><br><span class="line"> - Java</span><br><span class="line"> - Python</span><br><span class="line"> - Go</span><br><span class="line"> - PHP</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常工作中，我们经常会遇到 YAML，例如 docker-compose 配置，ELK 中的 filebeat 配置， K8S 集群配置，ansible 的 playbook 等，也有越来越多的项目使用了 YAML 作为配置文件的选型。那今天，我们就来了解下它到底是何许人也。&lt;/p&gt;
&lt;h1 id=&quot;什么是-YAML&quot;&gt;&lt;a href=&quot;#什么是-YAML&quot; class=&quot;headerlink&quot; title=&quot;什么是 YAML&quot;&gt;&lt;/a&gt;什么是 YAML&lt;/h1&gt;&lt;p&gt;YAML 官网：&lt;a href=&quot;https://yaml.org/&quot;&gt;https://yaml.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YAML (YAML: YAML Ain’t Markup Language) 是一种类似 XML，JSON 的数据序列化语言，是一种通用的数据串行化格式。它是主要用来写配置文件的语言，比 XML 要简洁和简单，便于人阅读理解，号称 &lt;code&gt;一种人性化的数据格式语言&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;正如其官网介绍，What It Is: YAML is a human friendly data serialization standard for all programming languages.&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.immaxfang.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://www.immaxfang.com/tags/Docker/"/>
    
      <category term="YAML" scheme="http://www.immaxfang.com/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>AWS 修改 RDS 时区</title>
    <link href="http://www.immaxfang.com/aws-rds-change-timezone/"/>
    <id>http://www.immaxfang.com/aws-rds-change-timezone/</id>
    <published>2021-07-18T15:05:40.000Z</published>
    <updated>2023-01-24T05:58:45.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看 -RDS- 当前时区"><a href="# 查看 -RDS- 当前时区" class="headerlink" title="查看 RDS 当前时区"></a>查看 RDS 当前时区 </h1><p> 默认情况下，AWS 的 RDS 采用的是 UTC 时间。而我们地区一般位于东八区，因此我们本地的时间是 UTC+8。</p><p>连接到 RDS 上，查询当前实例的时区。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">where</span> variable_name <span class="keyword">like</span> <span class="string">&#x27;time_zone&#x27;</span>;</span><br></pre></td></tr></table></figure><p>显示的结果如下，表示当前 RDS 时区的 UTC。</p><blockquote><p>time_zone   UTC</p></blockquote><span id="more"></span><h1 id="调整 -RDS- 时区"><a href="# 调整 -RDS- 时区" class="headerlink" title="调整 RDS 时区"></a>调整 RDS 时区</h1><p>RDS 的时区调整是通过调整参数组来操作的。AWS 的 RDS 是不允许修改 default 参数组的。因此先要确认下当前 RDS 采用的参数组是不是 default 参数组。如果是 default 参数组，则需要新建一个参数组。然后在该参数组上调整 timezone 相关参数，然后变更 RDS 使用的参数组，使用新的参数组。</p><p>从左侧的参数组菜单进入，即可新建参数组。一般我们都会从把当前在使用的参数组作为模版来复制一份新的来调整。<br>选择当前在使用的参数组，Actions-&gt;Copy 即可。以笔者测试为例，当前在使用的参数组为 pg-mysql57-demo ，复制过来的新的参数组为 pg-mysql57-demo-new 。</p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_1.jpg" alt="1"></p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_2.jpg" alt="2"></p><p>接下来就可以修改新的参数组的参数了，点击改参数组进入详情页面，搜索关键词 time_zone，然后点击 Modify 即可对参数进行修改，从可选值中找到我们需要的值，此处我们选择 Asia/Shanghai，最后确认变更即可。</p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_3.jpg" alt="3"></p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_4.jpg" alt="4"></p><p>再进入参数组，搜索 time_zone ，发现值已经修改为 Asia/Shanghai，说明已经修改完毕。</p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_5.jpg" alt="5"></p><p>参数组调增完毕了，接下来就是给对应实例应用该参数组了。<br>进入到需要调整的 RDS ，在参数组配置中，选择新的参数组。确认修改后，系统会提示是否立即应用修改。可以根据实际情况选择立即修改或者下一次维护窗口。修改 time_zone 需要重启数据库实例，这里我们选择下一次停机窗口重启。</p><p><img src="https://cdn.immaxfang.com/images/post/2021/aws_rds_timezone_6.jpg" alt="6"></p><p>选择合适的时机，重启 RDS 即可。</p><h1 id="验证修改生效"><a href="# 验证修改生效" class="headerlink" title="验证修改生效"></a>验证修改生效 </h1><p> 在 RDS 重启完毕之后，再次执行上面的查询时区的语句，显示的结果如下(Asia/Shanghai)，表示时区已修改成功。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">where</span> variable_name <span class="keyword">like</span> <span class="string">&#x27;time_zone&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>#time_zone    Asia/Shanghai</p></blockquote><hr><p>Happy Coding.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看-RDS-当前时区&quot;&gt;&lt;a href=&quot;#查看-RDS-当前时区&quot; class=&quot;headerlink&quot; title=&quot;查看 RDS 当前时区&quot;&gt;&lt;/a&gt;查看 RDS 当前时区&lt;/h1&gt;&lt;p&gt;默认情况下，AWS 的 RDS 采用的是 UTC 时间。而我们地区一般位于东八区，因此我们本地的时间是 UTC+8。&lt;/p&gt;
&lt;p&gt;连接到 RDS 上，查询当前实例的时区。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; variables &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; variable_name &lt;span class=&quot;keyword&quot;&gt;like&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;time_zone&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显示的结果如下，表示当前 RDS 时区的 UTC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;time_zone   UTC&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AWS" scheme="http://www.immaxfang.com/categories/AWS/"/>
    
    
      <category term="AWS" scheme="http://www.immaxfang.com/tags/AWS/"/>
    
      <category term="RDS" scheme="http://www.immaxfang.com/tags/RDS/"/>
    
      <category term="MySQL" scheme="http://www.immaxfang.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 调度任务不执行问题</title>
    <link href="http://www.immaxfang.com/case-laravel-schedule-not-run/"/>
    <id>http://www.immaxfang.com/case-laravel-schedule-not-run/</id>
    <published>2021-06-20T11:59:03.000Z</published>
    <updated>2023-01-24T05:59:01.053Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 laravel 的调度任务时候，有时候会出现正确配置了调度任务，但是脚本却没有执行的情况，具体什么问题呢，今天我们来分析一下。</p><h2 id="1- 什么原因造成的"><a href="#1- 什么原因造成的" class="headerlink" title="1. 什么原因造成的"></a>1. 什么原因造成的 </h2><p> 在使用 laravel 中的调度任务时，有些时候脚本一次的执行时间是不确定的，我们为了避免任务重复执行，会使用 withoutOverlapping 方法。withoutOverlapping 在调度任务开始时会创建一个锁，在该锁未过期之前，下一次的调度任务不会再次执行。默认情况下，这个锁的过期时间是 24h，当然也可以指定过期时间。关于这个锁的实现，会在后续文章中分析，实际上是一个互斥锁 (mutex)。</p><span id="more"></span><p>有些时候，由于一些特殊原因，导致上一次任务没有正常结束，这个锁还未过期情况下，就会出现调度任务不会执行的情况。</p><h2 id="2- 如何解决"><a href="#2- 如何解决" class="headerlink" title="2. 如何解决"></a>2. 如何解决 </h2><p> 这种情况下，处理的情况也比较简单，手动清除锁即可。这个锁的生成位置由 config/cache.php 指定，默认情况下，在配置的 CACHE_DRIVER 是 file 的情况下，只需要将 storage/framework/cache 下的文件删除即可。 </p><blockquote><p>Happy coding.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 laravel 的调度任务时候，有时候会出现正确配置了调度任务，但是脚本却没有执行的情况，具体什么问题呢，今天我们来分析一下。&lt;/p&gt;
&lt;h2 id=&quot;1-什么原因造成的&quot;&gt;&lt;a href=&quot;#1-什么原因造成的&quot; class=&quot;headerlink&quot; title=&quot;1.什么原因造成的&quot;&gt;&lt;/a&gt;1.什么原因造成的&lt;/h2&gt;&lt;p&gt;在使用 laravel 中的调度任务时，有些时候脚本一次的执行时间是不确定的，我们为了避免任务重复执行，会使用 withoutOverlapping 方法。withoutOverlapping 在调度任务开始时会创建一个锁，在该锁未过期之前，下一次的调度任务不会再次执行。默认情况下，这个锁的过期时间是 24h，当然也可以指定过期时间。关于这个锁的实现，会在后续文章中分析，实际上是一个互斥锁 (mutex)。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="http://www.immaxfang.com/categories/php/"/>
    
    
      <category term="php" scheme="http://www.immaxfang.com/tags/php/"/>
    
      <category term="laravel" scheme="http://www.immaxfang.com/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下 Chrome 的优雅操作</title>
    <link href="http://www.immaxfang.com/mac_chrome_hot_key/"/>
    <id>http://www.immaxfang.com/mac_chrome_hot_key/</id>
    <published>2021-02-20T18:09:09.000Z</published>
    <updated>2023-01-24T05:59:53.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标签页和窗口快捷键"><a href="# 标签页和窗口快捷键" class="headerlink" title="标签页和窗口快捷键"></a>标签页和窗口快捷键</h3><span id="more"></span><table><thead><tr><th style="text-align:left"><strong>⌘-N</strong></th><th style="text-align:left">打开新窗口</th></tr></thead><tbody><tr><td style="text-align:left"><strong>⌘-T</strong></td><td style="text-align:left">打开新标签页</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-N</strong></td><td style="text-align:left">在隐身模式下打开新窗口</td></tr><tr><td style="text-align:left">按 <strong>⌘-O</strong>，然后选择文件</td><td style="text-align:left">在 Chrome 浏览器中打开计算机中的文件</td></tr><tr><td style="text-align:left">按住 <strong>⌘</strong> 的同时点击链接。或用鼠标中键（或鼠标滚轮）点击链接</td><td style="text-align:left">从后台在新标签页中打开链接</td></tr><tr><td style="text-align:left">按住 <strong>⌘-Shift</strong> 的同时点击链接。或按住 <strong>Shift</strong> 键的同时用鼠标中键（或鼠标滚轮）点击链接</td><td style="text-align:left">在新标签页中打开链接并切换到刚打开的标签页</td></tr><tr><td style="text-align:left">按住 <strong>Shift</strong> 键的同时点击链接</td><td style="text-align:left">在新窗口中打开链接</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-T</strong></td><td style="text-align:left">重新打开上次关闭的标签页。Chrome 浏览器可记住最近关闭的 10 个标签页</td></tr><tr><td style="text-align:left">将标签页拖出标签栏</td><td style="text-align:left">在新窗口中打开标签页</td></tr><tr><td style="text-align:left">将标签页从标签栏拖到现有窗口中</td><td style="text-align:left">在现有窗口中打开标签页</td></tr><tr><td style="text-align:left">同时按 <strong>⌘-Option</strong> 和向右箭头键</td><td style="text-align:left">切换到下一个标签页</td></tr><tr><td style="text-align:left">同时按 <strong>⌘-Option</strong> 和向左箭头键</td><td style="text-align:left">切换到上一个标签页</td></tr><tr><td style="text-align:left"><strong>⌘-W</strong></td><td style="text-align:left">关闭当前标签页或弹出窗口</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-W</strong></td><td style="text-align:left">关闭当前窗口</td></tr><tr><td style="text-align:left">点击并按住浏览器工具栏中的后退或前进箭头</td><td style="text-align:left">在新标签页中显示浏览历史记录</td></tr><tr><td style="text-align:left">按 <strong>Delete</strong> 或 <strong>⌘-[</strong></td><td style="text-align:left">转到当前标签页的上一页浏览历史记录</td></tr><tr><td style="text-align:left">按 <strong>Shift-Delete</strong> 或 <strong>⌘-]</strong></td><td style="text-align:left">转到当前标签页的下一页浏览历史记录</td></tr><tr><td style="text-align:left">按住 <strong>Shift</strong> 键的同时点击窗口左上角的 + 按钮</td><td style="text-align:left">最大化窗口</td></tr><tr><td style="text-align:left"><strong>⌘-M</strong></td><td style="text-align:left">最小化窗口</td></tr><tr><td style="text-align:left"><strong>⌘-H</strong></td><td style="text-align:left">隐藏 Chrome 浏览器</td></tr><tr><td style="text-align:left"><strong>⌘-Option-H</strong></td><td style="text-align:left">隐藏其他所有窗口</td></tr><tr><td style="text-align:left"><strong>⌘-Q</strong></td><td style="text-align:left">关闭 Chrome 浏览器</td></tr></tbody></table><!-- more --><h3 id="Chrome- 浏览器功能快捷键"><a href="#Chrome- 浏览器功能快捷键" class="headerlink" title="Chrome 浏览器功能快捷键"></a>Chrome 浏览器功能快捷键</h3><table><thead><tr><th style="text-align:left"><strong>⌘-Shift-B</strong></th><th style="text-align:left">打开和关闭书签栏</th></tr></thead><tbody><tr><td style="text-align:left"><strong>⌘-Option-B</strong></td><td style="text-align:left">打开书签管理器</td></tr><tr><td style="text-align:left"><strong>⌘-,</strong></td><td style="text-align:left">打开“偏好设置”对话框</td></tr><tr><td style="text-align:left"><strong>⌘-Y</strong></td><td style="text-align:left">打开“历史记录”页</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-J</strong></td><td style="text-align:left">打开“下载内容”页</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-Delete</strong></td><td style="text-align:left">打开“清除浏览数据”对话框</td></tr></tbody></table><h3 id="地址栏快捷键"><a href="# 地址栏快捷键" class="headerlink" title="地址栏快捷键"></a>地址栏快捷键</h3><table><thead><tr><th style="text-align:left">键入搜索字词，然后按 <strong>Enter</strong> 键</th><th style="text-align:left">使用默认搜索引擎进行搜索</th></tr></thead><tbody><tr><td style="text-align:left">键入搜索引擎关键字，按 <strong> 空格键</strong>，然后键入搜索字词，再按 <strong>Enter</strong> 键</td><td style="text-align:left">使用与关键字相关联的搜索引擎进行搜索</td></tr><tr><td style="text-align:left">首先键入搜索引擎网址，然后在系统提示时按 <strong>Tab</strong> 键，键入搜索字词，再按 <strong>Enter</strong> 键</td><td style="text-align:left">使用与网址相关联的搜索引擎进行搜索</td></tr><tr><td style="text-align:left">键入网址，然后按 <strong>⌘-Enter</strong></td><td style="text-align:left">在新后台标签页中打开网址</td></tr><tr><td style="text-align:left"><strong>⌘-L</strong></td><td style="text-align:left">突出显示网址</td></tr><tr><td style="text-align:left"><strong>⌘-Option-F</strong></td><td style="text-align:left">在地址栏中输入“?”。在问号后键入搜索字词可用默认搜索引擎执行搜索</td></tr><tr><td style="text-align:left">同时按 <strong>Option</strong> 和向左箭头键</td><td style="text-align:left">将光标移到地址栏中的前一个关键字词</td></tr><tr><td style="text-align:left">同时按 <strong>Option</strong> 和向右箭头键</td><td style="text-align:left">在地址栏中将光标移到下一个关键字词</td></tr><tr><td style="text-align:left">同时按 <strong>Shift-Option</strong> 和向左箭头键</td><td style="text-align:left">在地址栏中突出显示上一关键字词</td></tr><tr><td style="text-align:left">同时按 <strong>Shift-Option</strong> 和向右箭头键</td><td style="text-align:left">在地址栏中突出显示下一关键字词</td></tr><tr><td style="text-align:left"><strong>⌘-Delete</strong></td><td style="text-align:left">在地址栏中删除光标前的字词</td></tr><tr><td style="text-align:left">在地址栏菜单中按 <strong>Page Up</strong> 或 <strong>Page Down</strong></td><td style="text-align:left">在菜单中选择上一条目或下一条目</td></tr></tbody></table><h3 id="网页快捷键"><a href="# 网页快捷键" class="headerlink" title="网页快捷键"></a>网页快捷键</h3><table><thead><tr><th style="text-align:left"><strong>⌘-P</strong></th><th style="text-align:left">打印当前网页</th></tr></thead><tbody><tr><td style="text-align:left"><strong>⌘-Shift-P</strong></td><td style="text-align:left">打开“网页设置”对话框</td></tr><tr><td style="text-align:left"><strong>⌘-S</strong></td><td style="text-align:left">保存当前网页</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-I</strong></td><td style="text-align:left">通过电子邮件发送当前网页</td></tr><tr><td style="text-align:left"><strong>⌘-R</strong></td><td style="text-align:left">重新载入当前网页</td></tr><tr><td style="text-align:left"><strong>⌘-,</strong></td><td style="text-align:left">停止载入当前网页</td></tr><tr><td style="text-align:left"><strong>⌘-F</strong></td><td style="text-align:left">打开查找栏</td></tr><tr><td style="text-align:left"><strong>⌘-G</strong></td><td style="text-align:left">在查找栏中查找下一条与输入内容相匹配的内容</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-G</strong> 或 <strong>Shift-Enter</strong></td><td style="text-align:left">在查找栏中查找上一条与输入内容相匹配的内容</td></tr><tr><td style="text-align:left"><strong>⌘-E</strong></td><td style="text-align:left">使用所选内容查找</td></tr><tr><td style="text-align:left"><strong>⌘-J</strong></td><td style="text-align:left">跳到所选内容</td></tr><tr><td style="text-align:left"><strong>⌘-Option-I</strong></td><td style="text-align:left">打开“开发人员工具”</td></tr><tr><td style="text-align:left"><strong>⌘-Option-J</strong></td><td style="text-align:left">打开“JavaScript 控制台”</td></tr><tr><td style="text-align:left"><strong>⌘-Option-U</strong></td><td style="text-align:left">打开当前网页的源代码</td></tr><tr><td style="text-align:left">按住 <strong>Option</strong> 键，然后点击链接</td><td style="text-align:left">下载链接目标</td></tr><tr><td style="text-align:left">将链接拖到书签栏中</td><td style="text-align:left">将链接保存为书签</td></tr><tr><td style="text-align:left"><strong>⌘-D</strong></td><td style="text-align:left">将当前网页保存为书签</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-D</strong></td><td style="text-align:left">将所有打开的标签页以书签的形式保存在新文件夹中</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-F</strong></td><td style="text-align:left">在全屏模式下打开网页。再按一次 <strong>⌘-Shift-F</strong> 可退出全屏模式</td></tr><tr><td style="text-align:left"><strong>⌘-+</strong></td><td style="text-align:left">放大网页上的所有内容</td></tr><tr><td style="text-align:left">⌘ 和 -</td><td style="text-align:left">缩小网页上的所有内容</td></tr><tr><td style="text-align:left"><strong>⌘-0</strong></td><td style="text-align:left">将网页上的所有内容恢复到正常大小</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-H</strong></td><td style="text-align:left">在当前标签页中打开主页</td></tr><tr><td style="text-align:left"><strong>空格键</strong></td><td style="text-align:left">向下滚动网页</td></tr><tr><td style="text-align:left"><strong>⌘-Option-F</strong></td><td style="text-align:left">搜索网页</td></tr></tbody></table><h3 id="文本快捷键"><a href="# 文本快捷键" class="headerlink" title="文本快捷键"></a>文本快捷键</h3><table><thead><tr><th style="text-align:left"><strong>⌘-C</strong></th><th style="text-align:left">将突出显示的内容复制到剪贴板中</th></tr></thead><tbody><tr><td style="text-align:left"><strong>⌘-Option-C</strong></td><td style="text-align:left">将您正在查看的网页的网址复制到剪贴板中</td></tr><tr><td style="text-align:left"><strong>⌘-V</strong></td><td style="text-align:left">从剪贴板中粘贴内容</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-Option-V</strong></td><td style="text-align:left">粘贴内容并应用周围文本的格式</td></tr><tr><td style="text-align:left"><strong>⌘-X</strong> 或 <strong>Shift-Delete</strong></td><td style="text-align:left">删除突出显示的内容并将其复制到剪贴板中</td></tr><tr><td style="text-align:left"><strong>⌘-Z</strong></td><td style="text-align:left">撤消最后一步操作</td></tr><tr><td style="text-align:left"><strong>⌘-Shift-Z</strong></td><td style="text-align:left">重复最后一步操作</td></tr><tr><td style="text-align:left"><strong>⌘-X</strong></td><td style="text-align:left">删除突出显示的内容并将其保存到剪贴板中（剪切）</td></tr><tr><td style="text-align:left"><strong>⌘-A</strong></td><td style="text-align:left">选择当前网页上的所有文本</td></tr><tr><td style="text-align:left"><strong>⌘-:</strong></td><td style="text-align:left">打开“拼写和语法”对话框</td></tr><tr><td style="text-align:left"><strong>⌘-;</strong></td><td style="text-align:left">检查当前网页上的拼写和语法</td></tr></tbody></table><p>Happy Coding.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;标签页和窗口快捷键&quot;&gt;&lt;a href=&quot;#标签页和窗口快捷键&quot; class=&quot;headerlink&quot; title=&quot;标签页和窗口快捷键&quot;&gt;&lt;/a&gt;标签页和窗口快捷键&lt;/h3&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.immaxfang.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.immaxfang.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="mac" scheme="http://www.immaxfang.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>MySQL- 出现 MySQL server has gone away 原因和解决方法</title>
    <link href="http://www.immaxfang.com/note-mysql-server-has-gone-away/"/>
    <id>http://www.immaxfang.com/note-mysql-server-has-gone-away/</id>
    <published>2020-12-08T14:53:27.000Z</published>
    <updated>2023-01-24T05:57:24.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可能的原因"><a href="# 可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h1><ul><li>MySQL 服务宕机</li><li>MySQL 连接被主动 kill 掉</li><li>MySQL 连接超时</li><li>SQL 超长，超出 max_allowed_packet 限制</li></ul><span id="more"></span><h1 id="具体情况分析和处理"><a href="# 具体情况分析和处理" class="headerlink" title="具体情况分析和处理"></a>具体情况分析和处理 </h1><h2 id="MySQL- 服务宕机"><a href="#MySQL- 服务宕机" class="headerlink" title="MySQL 服务宕机"></a>MySQL 服务宕机</h2><p> 可能是异常情况，访问过程中数据库宕机或重启了，期间的数据库访问请求会出现错误。<br>此种情况可以查看对应时候的 MySQL 相关日志，或者查询 MySQL 运行时间。可通过运行时间和日志，判断该时间是否有服务中断。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;uptime&#x27;;</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Variable_name | Value    |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Uptime        | 23948658 |</span><br><span class="line">+---------------+----------+</span><br></pre></td></tr></table></figure></p><h2 id="MySQL- 连接被主动 -kill- 掉"><a href="#MySQL- 连接被主动 -kill- 掉" class="headerlink" title="MySQL 连接被主动 kill 掉"></a>MySQL 连接被主动 kill 掉 </h2><p> 部分系统会配置一些连接数过多等情况下，脚本主动 kill 掉相关数据库请求进程，或者可能 DBA 等处理问题时手动 kill 掉，此种情况下也会出现报错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;com_kill&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Com_kill      | 100   |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure></p><h2 id="MySQL- 连接超时"><a href="#MySQL- 连接超时" class="headerlink" title="MySQL 连接超时"></a>MySQL 连接超时 </h2><p>MySQL 的连接开启后，很久没有发起新的查询请求，达到了 server 端的超时时间，被 server 端强制关闭连接。此时若该连接再次发起请求时，则会报错 MySQL server has gone away 。此种情况比较常见，一般一个执行时间很长的脚本，开启连接查询部分数据后，进行计算或者请求第三方，在进行数据写入，写入时超时。<br> 可以通过如下命令查看当前 MySQL 的超时时间，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &#x27;wait_timeout&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| wait_timeout  | 28800 |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure></p><p>可以通过如下命令临时修改超时时间，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global wait_timeout = 60 * 60 * 8;</span><br></pre></td></tr></table></figure><br>如要长期生效，则需要修改数据库配置文件，并重启 MySQL 服务。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wait_timeout = 28800</span><br><span class="line">interactive_timeout = 28800</span><br></pre></td></tr></table></figure></p><h2 id="SQL- 超长，超出 -max-allowed-packet- 限制"><a href="#SQL- 超长，超出 -max-allowed-packet- 限制" class="headerlink" title="SQL 超长，超出 max_allowed_packet 限制"></a>SQL 超长，超出 max_allowed_packet 限制</h2><p>MySQL 会限制 server 段接收的数据包的大小，有时候大的插入和更新发送的数据包大小超过 max_allowed_packet 的限制，服务端也会报错，导致写入或者更新失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &#x27;%max_allowed_packet%&#x27;;</span><br><span class="line">+--------------------------+------------+</span><br><span class="line">| Variable_name            | Value      |</span><br><span class="line">+--------------------------+------------+</span><br><span class="line">| max_allowed_packet       | 1048576   |</span><br><span class="line">+--------------------------+------------+</span><br></pre></td></tr></table></figure><p>可以通过如下命令临时修改，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global max_allowed_packet = 4 * 1024 * 1024;</span><br></pre></td></tr></table></figure></p><p>如要长期生效，则需要修改数据库配置文件，并重启 MySQL 服务。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_allowed_packet = 4M</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;可能的原因&quot;&gt;&lt;a href=&quot;#可能的原因&quot; class=&quot;headerlink&quot; title=&quot;可能的原因&quot;&gt;&lt;/a&gt;可能的原因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MySQL 服务宕机&lt;/li&gt;
&lt;li&gt;MySQL 连接被主动 kill 掉&lt;/li&gt;
&lt;li&gt;MySQL 连接超时&lt;/li&gt;
&lt;li&gt;SQL 超长，超出 max_allowed_packet 限制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.immaxfang.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.immaxfang.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>重新开启 hexo 博客</title>
    <link href="http://www.immaxfang.com/restart-hexo-blog/"/>
    <id>http://www.immaxfang.com/restart-hexo-blog/</id>
    <published>2020-11-22T13:25:48.000Z</published>
    <updated>2023-01-24T06:00:40.681Z</updated>
    
    <content type="html"><![CDATA[<p> 这些年尝试了不同的博客工具, hexo, hugo, wp, 还有一些博客内容平台，中间也自己写过博客系统。<br> 最终还是懒得再折腾了，重新切回 hexo，继续记录个人的学习生活。<br> 原来其他地方的文章也不搬了，继续开始吧。</p><p>Happy Coding.</p><span id="more"></span>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些年尝试了不同的博客工具, hexo, hugo, wp, 还有一些博客内容平台，中间也自己写过博客系统。&lt;br&gt;最终还是懒得再折腾了，重新切回 hexo，继续记录个人的学习生活。&lt;br&gt;原来其他地方的文章也不搬了，继续开始吧。&lt;/p&gt;
&lt;p&gt;Happy Coding.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
